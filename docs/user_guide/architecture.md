# System Architecture

This guide describes the architecture of NautilusTrader from the perspective of
design philosophy, system contexts, component organization and interaction, implementation techniques, and code structure.

## Code structure
The top-level dependency structure of the codebase includes a `nautilus_core` directory containing a collection of core Rust libraries, which provides a C API interface. 

The bulk of the production code resides in the `nautilus_trader` directory - being a collection of pure Python, Cython and some C headers (generated by `cbindgen`). 

The build statically links the Rust libraries to the Cython generated C extensions at compile time (effectively extending the CPython API).
Resulting in Python bindings for the Rust core.

```{note}
Both Rust and Cython are build dependencies. The binary wheels produced from a build do not themselves require
Cython or Rust to be installed at runtime.
```

### Dependency flow
```
┌─────────────────────────┐
│                         │
│                         │
│     nautilus_trader     │
│                         │
│     Python / Cython     │
│                         │
│                         │
└────────────┬────────────┘
 C API       │
             │
             │
             │
 C API       ▼
┌─────────────────────────┐
│                         │
│                         │
│      nautilus_core      │
│                         │
│          Rust           │
│                         │
│                         │
└─────────────────────────┘
```

## Python type safety
The design of the platform holds software correctness and safety at the highest level.
Given most of the core production code is written in Cython, type safety is often provided
at the C level.

```{note}
If you pass an argument with an invalid type to a C extension module provided by Cython with a typed 
parameter, then you will receive a ``TypeError`` at runtime.

If a function or methods parameter is not explicitly typed as allowing
``None``, then you can assume you will receive a `ValueError` when passing ``None``
as an argument at runtime.

Both of these exceptions are not explicitly documented (as this would bloat the docstrings significantly).
```

## Python framework organization
The codebase is organized around both layering of abstraction levels, and generally
grouped into logical subpackages of cohesive concepts. You can navigate to the documentation
for each of these subpackages from the left menu.

### Core / low-Level
- `core`: constants, functions and low-level components used throughout the framework
- `common`: common parts for assembling the frameworks various components
- `network`: low-level base components for networking clients
- `serialization`: serialization base components and serializer implementations
- `model`: defines a rich trading domain model

### System components
- `accounting`: different account types and account management machinery
- `adapters`: integration adapters for the platform including brokers and exchanges
- `analysis`: components relating to trading performance statistics and analysis
- `cache`: provides common caching infrastructure
- `data`: the data stack and data tooling for the platform
- `execution`: the execution stack for the platform
- `indicators`: a set of efficient indicators and analyzers
- `infrastructure`: technology specific infrastructure implementations
- `msgbus`: a universal message bus for connecting system components
- `persistence`: data storage, cataloging and retrieval, mainly to support backtesting
- `portfolio`: portfolio management functionality
- `risk`: risk specific components and tooling
- `trading`: trading domain specific components and tooling

### System implementations
- `backtest`: backtesting componentry as well as a backtest engine implementation
- `live`: live engine and client implementations as well as a node for live trading
- `system`: the core system kernel common between backtest, sandbox and live contexts

## Errors and exceptions
Every attempt has been made to accurately document the possible exceptions which
can be raised from NautilusTrader code, and the conditions which will trigger them.

```{warning}
There may be other undocumented exceptions which can be raised by Pythons standard 
library, or from third party library dependencies.
```

## System structure

### Common core
NautilusTrader has been designed to share as much common code between backtest and live systems as possible. This
is formalized in the `system` subpackage, where you will find the `NautilusKernel` class, providing a common core system kernel.

A _ports and adapters_ architectural style allows modular components to be 'plugged into' the
core system, providing many hook points for user defined / custom implementations.

### Messaging
To facilitate this modularity and loose coupling, an extremely efficient `MessageBus` passes data, commands and events as messages between components.

From a high level architectural view, it's important to understand that the platform has been designed to run efficiently 
on a single thread, for both backtesting and live trading. A lot of research and testing
resulted in arriving at this design, as it was found the overhead of context switching between threads
didn't pay off in better performance.

When considering the logic of how your trading will work within the system boundary, you can expect each component to consume messages
in a predictable synchronous way (_similar_ to the [actor model](https://en.wikipedia.org/wiki/Actor_model)).

```{note}
Of interest is the LMAX exchange architecture, which achieves award winning performance running on
a single thread. You can read about their _disruptor_ pattern based architecture in [this interesting article](https://martinfowler.com/articles/lmax.html) by Martin Fowler.
```

