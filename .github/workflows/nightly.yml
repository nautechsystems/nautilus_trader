# name: nightly
#
# on:
#   schedule:
#     # Run at 1300 UTC daily
#     - cron: '0 13 * * *'
#
# jobs:
#   nightly-update:
#     runs-on: ubuntu-latest
#
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4
#         with:
#           fetch-depth: 0  # fetch all history so we can operate on branches correctly
#
#       - name: Get last successful build commit
#         id: get-commit
#         run: |
#           max_retries=3
#           retry_delay=10 # 10 seconds delay between retries
#
#           retry_cmd() {
#             local retries=0
#             until [ $retries -ge $max_retries ]
#             do
#               $@ && break  # Execute the command. If it succeeds, break out of the loop.
#               retries=$[$retries+1]
#               echo "Failed! ($retries/$max_retries). Retrying in $retry_delay seconds..."
#               sleep $retry_delay
#             done
#
#             if [ $retries -eq $max_retries ]; then
#               echo "Command failed after $max_retries attempts."
#               exit 1
#             fi
#           }
#
#           # Use retry_cmd with curl:
#           commits=$(retry_cmd curl -H "Accept: application/vnd.github.v3+json" \
#                                    -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
#                                    "https://api.github.com/repos/${{ github.repository }}/commits?sha=develop" | \
#                     jq -r '.[].sha')
#
#           for commit_sha in $commits; do
#             # Check status of the 'build' workflow for the commit using retry_cmd
#             status=$(retry_cmd curl -H "Accept: application/vnd.github.v3+json" \
#                                     -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
#                                     "https://api.github.com/repos/${{ github.repository }}/commits/$commit_sha/check-runs?check_name=build" | \
#                      jq -r '.check_runs[0].conclusion')
#             if [ "$status" == "success" ]; then
#               echo "Last successful build commit SHA is $commit_sha"
#               echo "COMMIT_SHA=$commit_sha" >> $GITHUB_ENV
#               break
#             fi
#           done
#
#       - name: Fetch all from origin
#         run: git fetch origin
#
#       - name: Ensure nightly branch exists
#         run: |
#           # Check if the 'nightly' branch exists in the remote
#           if ! git show-ref --quiet refs/remotes/origin/nightly; then
#             # Create and push the 'nightly' branch if it doesn't exist
#             git checkout -b nightly
#             git push origin nightly
#           fi
#
#       - name: Check if nightly branch needs an update
#         id: check-nightly
#         run: |
#           # Fetch the current head of the nightly branch
#           nightly_sha=$(git rev-parse refs/remotes/origin/nightly)
#
#           if [ "$nightly_sha" == "${{ env.COMMIT_SHA }}" ]; then
#             echo "The nightly branch is already up to date. No need to update."
#             echo "UPDATE_REQUIRED=false" >> $GITHUB_ENV
#           else
#             echo "The nightly branch needs an update."
#             echo "UPDATE_REQUIRED=true" >> $GITHUB_ENV
#           fi
#
#       - name: Update nightly branch
#         if: env.UPDATE_REQUIRED == 'true'
#         run: |
#           git checkout nightly
#           git reset --hard ${{ env.COMMIT_SHA }}
#           git push origin nightly
#
#   nightly-prerelease:
#     needs: nightly-update
#     runs-on: ubuntu-latest
#     outputs:
#       upload_url: ${{ steps.create_release.outputs.upload_url }}
#
#     steps:
#       - name: Set up Python environment
#         uses: actions/setup-python@v4
#         with:
#           python-version: "3.11"
#
#       - name: Get Poetry version from poetry-version
#         run: |
#           version=$(cat poetry-version)
#           echo "POETRY_VERSION=$version" >> $GITHUB_ENV
#
#       - name: Install Poetry
#         uses: snok/install-poetry@v1
#         with:
#           version: ${{ env.POETRY_VERSION }}
#
#       - name: Check if nightly release exists
#         id: check_release
#         run: |
#           response=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
#             "https://api.github.com/repos/${{ github.repository }}/releases/tags/nightly-${{ github.sha }}")
#
#           upload_url=$(echo $response | jq -r '.upload_url' | sed "s/{?name,label}//")  # Extract the upload_url without its parameters
#
#           # Set the result to an output variable or environment variable
#           if [ "$upload_url" != "null" ]; then
#             echo "Nightly release already exists with upload_url: $upload_url"
#             echo "UPLOAD_URL=$upload_url" >> $GITHUB_ENV
#             echo "RELEASE_EXISTS=true" >> $GITHUB_ENV
#           else
#             echo "RELEASE_EXISTS=false" >> $GITHUB_ENV
#           fi
#
#       - name: Set output
#         id: vars
#         run: |
#           echo "TAG_NAME=v$(poetry version --short)" >> $GITHUB_ENV
#           echo "RELEASE_NAME=NautilusTrader $(poetry version --short) Beta (pre-release)" >> $GITHUB_ENV
#           sed -n '/^#/,${p;/^---/q};w RELEASE.md' RELEASES.md
#
#       - name: Create GitHub Pre-Release
#         if: env.RELEASE_EXISTS == 'false'
#         id: create_release
#         uses: actions/create-release@v1
#         env:
#           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#         with:
#           tag_name: nightly-${{ env.TAG_NAME }}
#           release_name: ${{ env.RELEASE_NAME }}
#           draft: false
#           prerelease: true
#
#   nightly-wheels:
#     needs: nightly-prerelease
#     strategy:
#       fail-fast: false
#       matrix:
#         arch: [x64]
#         os: [ubuntu-20.04, ubuntu-latest, windows-latest]
#         python-version: ["3.9", "3.10", "3.11"]
#     defaults:
#       run:
#         shell: bash
#     name: publish-wheels - Python ${{ matrix.python-version }} (${{ matrix.arch }} ${{ matrix.os }})
#     runs-on: ${{ matrix.os }}
#     env:
#       BUILD_MODE: release
#
#     steps:
#       - name: Checkout repository
#         uses: actions/checkout@v4
#
#       - name: Get Rust version from rust-toolchain.toml
#         id: rust-version
#         run: |
#           version=$(awk -F\" '/version/ {print $2}' nautilus_core/rust-toolchain.toml)
#           echo "Rust toolchain version $version"
#           echo "RUST_VERSION=$version" >> $GITHUB_ENV
#         working-directory: ${{ github.workspace }}
#
#       - name: Set up Rust tool-chain (Linux, Windows) stable
#         if: (runner.os == 'Linux') || (runner.os == 'Windows')
#         uses: actions-rust-lang/setup-rust-toolchain@v1.5
#         with:
#           toolchain: ${{ env.RUST_VERSION }}
#           components: rustfmt, clippy
#
#       # Work around as actions-rust-lang does not seem to work on macOS yet
#       - name: Set up Rust tool-chain (macOS) stable
#         if: runner.os == 'macOS'
#         uses: actions-rs/toolchain@v1
#         with:
#           toolchain: ${{ env.RUST_VERSION }}
#           override: true
#           components: rustfmt, clippy
#
#       - name: Set up Python environment
#         uses: actions/setup-python@v4
#         with:
#           python-version: ${{ matrix.python-version }}
#
#       - name: Get Poetry version from poetry-version
#         run: |
#           version=$(cat poetry-version)
#           echo "POETRY_VERSION=$version" >> $GITHUB_ENV
#
#       - name: Install Poetry
#         uses: snok/install-poetry@v1
#         with:
#           version: ${{ env.POETRY_VERSION }}
#
#       - name: Install build dependencies
#         run: python -m pip install --upgrade pip setuptools wheel pre-commit msgspec
#
#       - name: Set poetry output
#         run: echo "dir=$(poetry config cache-dir)" >> $GITHUB_ENV
#
#       - name: Poetry cache
#         id: cached-poetry
#         uses: actions/cache@v3
#         with:
#           path: ${{ env.dir }}
#           key: ${{ runner.os }}-${{ matrix.python-version }}-poetry-${{ hashFiles('**/poetry.lock') }}
#
#       - name: Install / Build
#         run: |
#           poetry install
#           poetry build --format wheel
#
#       - name: Set output for release
#         id: vars-release
#         run: |
#           echo "ASSET_PATH=$(find ./dist -mindepth 1 -print -quit)" >> $GITHUB_ENV
#           cd dist
#           echo "ASSET_NAME=$(printf '%s\0' * | awk 'BEGIN{RS="\0"} {print;  exit}')" >> $GITHUB_ENV
#
#       - name: Upload release asset
#         id: upload-release-asset-unix
#         uses: actions/upload-release-asset@v1
#         env:
#           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#         with:
#           upload_url: ${{ needs.create-release.outputs.upload_url }}
#           asset_path: ${{ env.ASSET_PATH }}
#           asset_name: ${{ env.ASSET_NAME }}
#           asset_content_type: application/wheel
