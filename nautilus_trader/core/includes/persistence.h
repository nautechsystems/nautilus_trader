/* Generated with cbindgen:0.24.3 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <Python.h>

/**
 * Types that implement parquet reader writer traits should also have a
 * corresponding enum so that they can be passed across the ffi.
 */
typedef enum ParquetType {
    QuoteTick = 0,
    TradeTick = 1,
} ParquetType;

/**
 * Filter groups based on a field's metadata values
 */
typedef enum GroupFilterArg_Tag {
    /**
     * select groups that have minimum ts_init less than limit
     */
    TsInitLt,
    /**
     * select groups that have maximum ts_init greater than limit
     */
    TsInitGt,
    /**
     * TODO: a blank case to avoid wrapping in option because
     * option does not cross ffi very well
     */
    None,
} GroupFilterArg_Tag;

typedef struct GroupFilterArg {
    GroupFilterArg_Tag tag;
    union {
        struct {
            uint64_t ts_init_lt;
        };
        struct {
            uint64_t ts_init_gt;
        };
    };
} GroupFilterArg;

/**
 * TODO: is this needed?
 * # Safety
 */
CVec parquet_writer_chunk_append(CVec chunk, void *item, enum ParquetType reader_type);

/**
 * # Safety
 * - Assumes `writer` is a valid `*mut ParquetWriter<Struct>` where the struct
 * has a corresponding ParquetType enum.
 * - Assumes  `data` is a non-null valid pointer to a contiguous block of
 * C-style structs with `len` number of elements
 */
void parquet_writer_write(void *writer, enum ParquetType writer_type, void *data, uintptr_t len);

/**
 * # Safety
 * - Assumes `file_path` is borrowed from a valid Python UTF-8 `str`.
 * - Assumes `metadata` is borrowed from a valid Python `dict`.
 */
void *parquet_writer_new(PyObject *file_path, enum ParquetType writer_type, PyObject *metadata);

/**
 * # Safety
 * - Assumes `writer` is a valid `*mut ParquetWriter<Struct>` where the struct
 * has a corresponding ParquetType enum.
 */
void parquet_writer_drop(void *writer, enum ParquetType writer_type);

/**
 * # Safety
 * - Assumes `file_path` is a valid `*mut ParquetReader<QuoteTick>`.
 */
void *parquet_reader_new(PyObject *file_path,
                         enum ParquetType reader_type,
                         uintptr_t chunk_size,
                         struct GroupFilterArg group_filter_arg);

/**
 * # Safety
 * - Assumes `reader` is a valid `*mut ParquetReader<Struct>` where the struct
 * has a corresponding ParquetType enum.
 */
void parquet_reader_drop(void *reader, enum ParquetType reader_type);

/**
 * # Safety
 * - Assumes `reader` is a valid `*mut ParquetReader<Struct>` where the struct
 * has a corresponding ParquetType enum.
 */
CVec parquet_reader_next_chunk(void *reader, enum ParquetType reader_type);

/**
 * # Safety
 * - Assumes `chunk` is a valid `ptr` pointer to a contiguous array.
 */
void *parquet_reader_index_chunk(CVec chunk, enum ParquetType reader_type, uintptr_t index);

/**
 * # Safety
 * - Assumes `chunk` is a valid `ptr` pointer to a contiguous array.
 */
void parquet_reader_drop_chunk(CVec chunk, enum ParquetType reader_type);
