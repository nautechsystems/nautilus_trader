# Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

from libc.stdint cimport uint8_t, uint16_t, uint64_t, uintptr_t, int64_t
from nautilus_trader.core.rust.core cimport CVec, UUID4_t

cdef extern from "../includes/model.h":

    const uint8_t FIXED_PRECISION # = 9

    const double FIXED_SCALAR # = 1000000000.0

    const double MONEY_MAX # = 9223372036.0

    const double MONEY_MIN # = -9223372036.0

    const double PRICE_MAX # = 9223372036.0

    const double PRICE_MIN # = -9223372036.0

    const double QUANTITY_MAX # = 18446744073.0

    const double QUANTITY_MIN # = 0.0

    # An account type provided by a trading venue or broker.
    cpdef enum AccountType:
        # An account with unleveraged cash assets only.
        CASH # = 1,
        # An account which facilitates trading on margin, using account assets as collateral.
        MARGIN # = 2,
        # An account specific to betting markets.
        BETTING # = 3,

    # An aggregation source for derived data.
    cpdef enum AggregationSource:
        # The data is externally aggregated (outside the Nautilus system boundary).
        EXTERNAL # = 1,
        # The data is internally aggregated (inside the Nautilus system boundary).
        INTERNAL # = 2,

    # The side for the aggressing order of a trade in a market.
    cpdef enum AggressorSide:
        # There was no specific aggressor for the trade.
        NO_AGGRESSOR # = 0,
        # The BUY order was the aggressor for the trade.
        BUYER # = 1,
        # The SELL order was the aggressor for the trade.
        SELLER # = 2,

    # A broad financial market asset class.
    cpdef enum AssetClass:
        # Foreign exchange (FOREX) assets.
        FX # = 1,
        # Equity / stock assets.
        EQUITY # = 2,
        # Commodity assets.
        COMMODITY # = 3,
        # Metal commodity assets.
        METAL # = 4,
        # Energy commodity assets.
        ENERGY # = 5,
        # Fixed income bond assets.
        BOND # = 6,
        # Index based assets.
        INDEX # = 7,
        # Cryptocurrency or crypto token assets.
        CRYPTOCURRENCY # = 8,
        # Sports betting instruments.
        SPORTS_BETTING # = 9,

    # The asset type for a financial market product.
    cpdef enum AssetType:
        # A spot market asset type. The current market price of an asset that is bought or sold for immediate delivery and payment.
        SPOT # = 1,
        # A swap asset type. A derivative contract through which two parties exchange the cash flows or liabilities from two different financial instruments.
        SWAP # = 2,
        # A futures contract asset type. A legal agreement to buy or sell an asset at a predetermined price at a specified time in the future.
        FUTURE # = 3,
        # A forward derivative asset type. A customized contract between two parties to buy or sell an asset at a specified price on a future date.
        FORWARD # = 4,
        # A contract-for-difference (CFD) asset type. A contract between an investor and a CFD broker to exchange the difference in the value of a financial product between the time the contract opens and closes.
        CFD # = 5,
        # An options contract asset type. A type of derivative that gives the holder the right, but not the obligation, to buy or sell an underlying asset at a predetermined price before or at a certain future date.
        OPTION # = 6,
        # A warrant asset type. A derivative that gives the holder the right, but not the obligation, to buy or sell a security—most commonly an equity—at a certain price before expiration.
        WARRANT # = 7,

    # The type of order book action for an order book event.
    cpdef enum BookAction:
        # An order is added to the book.
        ADD # = 1,
        # An existing order in the book is updated/modified.
        UPDATE # = 2,
        # An existing order in the book is deleted/canceled.
        DELETE # = 3,
        # The state of the order book is cleared.
        CLEAR # = 4,

    # The order book type, representing the type of levels granularity and delta updating heuristics.
    cpdef enum BookType:
        # Top-of-book best bid/offer, one level per side.
        L1_TBBO # = 1,
        # Market by price, one order per level (aggregated).
        L2_MBP # = 2,
        # Market by order, multiple orders per level (full granularity).
        L3_MBO # = 3,

    # The order contigency type which specifies the behaviour of linked orders.
    #
    # [FIX 5.0 SP2 : ContingencyType <1385> field](https://www.onixs.biz/fix-dictionary/5.0.sp2/tagnum_1385.html).
    cpdef enum ContingencyType:
        # Not a contingent order.
        NO_CONTINGENCY # = 0,
        # One-Cancels-the-Other.
        OCO # = 1,
        # One-Triggers-the-Other.
        OTO # = 2,
        # One-Updates-the-Other (by proportional quantity).
        OUO # = 3,

    # The broad currency type.
    cpdef enum CurrencyType:
        # A type of cryptocurrency or crypto token.
        CRYPTO # = 1,
        # A type of currency issued by governments which is not backed by a commodity.
        FIAT # = 2,

    # The type of event for an instrument close.
    cpdef enum InstrumentCloseType:
        # When the market session ended.
        END_OF_SESSION # = 1,
        # When the instrument expiration was reached.
        CONTRACT_EXPIRED # = 2,

    # The liqudity side for a trade in a financial market.
    cpdef enum LiquiditySide:
        # No specific liqudity side.
        NO_LIQUIDITY_SIDE # = 0,
        # The order passively provided liqudity to the market to complete the trade (made a market).
        MAKER # = 1,
        # The order aggressively took liqudity from the market to complete the trade.
        TAKER # = 2,

    # The status of an individual market on a trading venue.
    cpdef enum MarketStatus:
        # The market is closed.
        CLOSED # = 1,
        # The market is in the pre-open session.
        PRE_OPEN # = 2,
        # The market is open for the normal session.
        OPEN # = 3,
        # The market session is paused.
        PAUSE # = 4,
        # The market is in the pre-close session.
        PRE_CLOSE # = 5,

    # The order management system (OMS) type for a trading venue or trading strategy.
    cpdef enum OmsType:
        # There is no specific type of order management specified (will defer to the venue).
        UNSPECIFIED # = 0,
        # The netting type where there is one position per instrument.
        NETTING # = 1,
        # The hedging type where there can be multiple positions per instrument.
        # This can be in LONG/SHORT directions, by position/ticket ID, or tracked virtually by
        # Nautilus.
        HEDGING # = 2,

    # The kind of options contract.
    cpdef enum OptionKind:
        # A Call option gives the holder the right, but not the obligation, to buy an underlying asset at a specified strike price within a specified period of time.
        CALL # = 1,
        # A Put option gives the holder the right, but not the obligation, to sell an underlying asset at a specified strike price within a specified period of time.
        PUT # = 2,

    # The order side for a specific order, or action related to orders.
    cpdef enum OrderSide:
        # No order side is specified (only valid in the context of a filter for actions involving orders).
        NO_ORDER_SIDE # = 0,
        # The order is a BUY.
        BUY # = 1,
        # The order is a SELL.
        SELL # = 2,

    # The status for a specific order.
    #
    # An order is considered _open_ for the following status:
    #  - `ACCEPTED`
    #  - `TRIGGERED`
    #  - `PENDING_UPDATE`
    #  - `PENDING_CANCEL`
    #  - `PARTIALLY_FILLED`
    #
    # An order is considered _in-flight_ for the following status:
    #  - `SUBMITTED`
    #  - `PENDING_UPDATE`
    #  - `PENDING_CANCEL`
    #
    # An order is considered _closed_ for the following status:
    #  - `DENIED`
    #  - `REJECTED`
    #  - `CANCELED`
    #  - `EXPIRED`
    #  - `FILLED`
    cpdef enum OrderStatus:
        # The order is initialized (instantiated) within the Nautilus system.
        INITIALIZED # = 1,
        # The order was denied by the Nautilus system, either for being invalid, unprocessable or exceeding a risk limit.
        DENIED # = 2,
        # The order was submitted by the Nautilus system to the external service or trading venue (closed/done).
        SUBMITTED # = 3,
        # The order was acknowledged by the trading venue as being received and valid (may now be working).
        ACCEPTED # = 4,
        # The order was rejected by the trading venue.
        REJECTED # = 5,
        # The order was canceled (closed/done).
        CANCELED # = 6,
        # The order reached a GTD expiration (closed/done).
        EXPIRED # = 7,
        # The order STOP price was triggered (closed/done).
        TRIGGERED # = 8,
        # The order is currently pending a request to modify at the trading venue.
        PENDING_UPDATE # = 9,
        # The order is currently pending a request to cancel at the trading venue.
        PENDING_CANCEL # = 10,
        # The order has been partially filled at the trading venue.
        PARTIALLY_FILLED # = 11,
        # The order has been completely filled at the trading venue (closed/done).
        FILLED # = 12,

    # The type of order.
    cpdef enum OrderType:
        # A market order to buy or sell at the best available price in the current market.
        MARKET # = 1,
        # A limit order to buy or sell at a specific price or better.
        LIMIT # = 2,
        # A stop market order to buy or sell once the price reaches the specified stop/trigger price. When the stop price is reached, the order effectively becomes a market order.
        STOP_MARKET # = 3,
        # A stop limit order to buy or sell which combines the features of a stop order and a limit order. Once the stop/trigger price is reached, a stop-limit order effectively becomes a limit order.
        STOP_LIMIT # = 4,
        # A market-to-limit order is a market order that is to be executed as a limit order at the current best market price after reaching the market.
        MARKET_TO_LIMIT # = 5,
        # A market-if-touched order effectively becomes a market order when the specified trigger price is reached.
        MARKET_IF_TOUCHED # = 6,
        # A limit-if-touched order effectively becomes a limit order when the specified trigger price is reached.
        LIMIT_IF_TOUCHED # = 7,
        # A trailing stop market order sets the stop/trigger price at a fixed "trailing offset" amount from the market.
        TRAILING_STOP_MARKET # = 8,
        # A trailing stop limit order combines the features of a trailing stop order with those of a limit order.
        TRAILING_STOP_LIMIT # = 9,

    # The market side for a specific position, or action related to positions.
    cpdef enum PositionSide:
        # No position side is specified (only valid in the context of a filter for actions involving positions).
        NO_POSITION_SIDE # = 0,
        # A neural/flat position, where no position is currently held in the market.
        FLAT # = 1,
        # A long position in the market, typically acquired through one or many BUY orders.
        LONG # = 2,
        # A short position in the market, typically acquired through one or many SELL orders.
        SHORT # = 3,

    # The type of price for an instrument in a financial market.
    cpdef enum PriceType:
        # A quoted order price where a buyer is willing to buy a quantity of an instrument.
        BID # = 1,
        # A quoted order price where a seller is willing to sell a quantity of an instrument.
        ASK # = 2,
        # The midpoint between the bid and ask prices.
        MID # = 3,
        # The last price at which a trade was made for an instrument.
        LAST # = 4,

    # The 'Time in Force' instruction for an order in the financial market.
    cpdef enum TimeInForce:
        # Good Till Canceled (GTC) - the order remains active until canceled.
        GTC # = 1,
        # Immediate or Cancel (IOC) - the order is filled as much as possible, the rest is canceled.
        IOC # = 2,
        # Fill or Kill (FOK) - the order must be executed in full immediately, or it is canceled.
        FOK # = 3,
        # Good Till Date/Time (GTD) - the order is active until a specified date or time.
        GTD # = 4,
        # Day - the order is active until the end of the current trading session.
        DAY # = 5,
        # At the Opening (ATO) - the order is scheduled to be executed at the market's opening.
        AT_THE_OPEN # = 6,
        # At the Closing (ATC) - the order is scheduled to be executed at the market's closing.
        AT_THE_CLOSE # = 7,

    # The trading state for a node.
    cpdef enum TradingState:
        # Normal trading operations.
        ACTIVE # = 1,
        # Trading is completely halted, no new order commands will be emitted.
        HALTED # = 2,
        # Only order commands which would cancel order, or reduce position sizes are permitted.
        REDUCING # = 3,

    # The trailing offset type for an order type which specifies a trailing stop/trigger or limit price.
    cpdef enum TrailingOffsetType:
        # No trailing offset type is specified (invalid for trailing type orders).
        NO_TRAILING_OFFSET # = 0,
        # The trailing offset is based on a market price.
        PRICE # = 1,
        # The trailing offset is based on a percentage represented in basis points, of a market price.
        BASIS_POINTS # = 2,
        # The trailing offset is based on the number of ticks from a market price.
        TICKS # = 3,
        # The trailing offset is based on a price tier set by a specific trading venue.
        PRICE_TIER # = 4,

    # The trigger type for the stop/trigger price of an order.
    cpdef enum TriggerType:
        # No trigger type is specified (invalid for orders with a trigger).
        NO_TRIGGER # = 0,
        # The default trigger type set by the trading venue.
        DEFAULT # = 1,
        # Based on the top-of-book quoted prices for the instrument.
        BID_ASK # = 2,
        # Based on the last traded price for the instrument.
        LAST_TRADE # = 3,
        # Based on a 'double match' of the last traded price for the instrument
        DOUBLE_LAST # = 4,
        # Based on a 'double match' of the bid/ask price for the instrument
        DOUBLE_BID_ASK # = 5,
        # Based on both the [`TriggerType::LastTrade`] and [`TriggerType::BidAsk`].
        LAST_OR_BID_ASK # = 6,
        # Based on the mid-point of the [`TriggerType::BidAsk`].
        MID_POINT # = 7,
        # Based on the mark price for the instrument.
        MARK_PRICE # = 8,
        # Based on the index price for the instrument.
        INDEX_PRICE # = 9,

    cdef struct Arc_String:
        pass

    cdef struct OrderBook:
        pass

    cdef struct String:
        pass

    # Represents a synthetic instrument with prices derived from component instruments using a
    # formula.
    cdef struct SyntheticInstrument:
        pass

    cdef struct Symbol_t:
        Arc_String *value;

    cdef struct Venue_t:
        Arc_String *value;

    cdef struct InstrumentId_t:
        Symbol_t symbol;
        Venue_t venue;

    cdef struct Price_t:
        int64_t raw;
        uint8_t precision;

    cdef struct Quantity_t:
        uint64_t raw;
        uint8_t precision;

    # Represents an order in a book.
    cdef struct BookOrder_t:
        # The order side.
        OrderSide side;
        # The order price.
        Price_t price;
        # The order size.
        Quantity_t size;
        # The order ID.
        uint64_t order_id;

    # Represents a single change/delta in an order book.
    cdef struct OrderBookDelta_t:
        # The instrument ID for the book.
        InstrumentId_t instrument_id;
        # The order book delta action.
        BookAction action;
        # The order to apply.
        BookOrder_t order;
        # A combination of packet end with matching engine status.
        uint8_t flags;
        # The message sequence number assigned at the venue.
        uint64_t sequence;
        # The UNIX timestamp (nanoseconds) when the data event occurred.
        uint64_t ts_event;
        # The UNIX timestamp (nanoseconds) when the data object was initialized.
        uint64_t ts_init;

    # Represents a single quote tick in a financial market.
    cdef struct QuoteTick_t:
        # The quotes instrument ID.
        InstrumentId_t instrument_id;
        # The top of book bid price.
        Price_t bid;
        # The top of book ask price.
        Price_t ask;
        # The top of book bid size.
        Quantity_t bid_size;
        # The top of book ask size.
        Quantity_t ask_size;
        # The UNIX timestamp (nanoseconds) when the tick event occurred.
        uint64_t ts_event;
        # The UNIX timestamp (nanoseconds) when the data object was initialized.
        uint64_t ts_init;

    cdef struct TradeId_t:
        Arc_String *value;

    # Represents a single trade tick in a financial market.
    cdef struct TradeTick_t:
        # The trade instrument ID.
        InstrumentId_t instrument_id;
        # The traded price.
        Price_t price;
        # The traded size.
        Quantity_t size;
        # The trade aggressor side.
        AggressorSide aggressor_side;
        # The trade match ID (assigned by the venue).
        TradeId_t trade_id;
        # The UNIX timestamp (nanoseconds) when the tick event occurred.
        uint64_t ts_event;
        #  The UNIX timestamp (nanoseconds) when the data object was initialized.
        uint64_t ts_init;

    # Represents a bar aggregation specification including a step, aggregation
    # method/rule and price type.
    cdef struct BarSpecification_t:
        # The step for binning samples for bar aggregation.
        uint64_t step;
        # The type of bar aggregation.
        uint8_t aggregation;
        # The price type to use for aggregation.
        PriceType price_type;

    # Represents a bar type including the instrument ID, bar specification and
    # aggregation source.
    cdef struct BarType_t:
        # The bar types instrument ID.
        InstrumentId_t instrument_id;
        # The bar types specification.
        BarSpecification_t spec;
        # The bar types aggregation source.
        AggregationSource aggregation_source;

    # Represents an aggregated bar.
    cdef struct Bar_t:
        # The bar type for this bar.
        BarType_t bar_type;
        # The bars open price.
        Price_t open;
        # The bars high price.
        Price_t high;
        # The bars low price.
        Price_t low;
        # The bars close price.
        Price_t close;
        # The bars volume.
        Quantity_t volume;
        # The UNIX timestamp (nanoseconds) when the data event occurred.
        uint64_t ts_event;
        # The UNIX timestamp (nanoseconds) when the data object was initialized.
        uint64_t ts_init;

    cpdef enum Data_t_Tag:
        DELTA,
        QUOTE,
        TRADE,
        BAR,

    cdef struct Data_t:
        Data_t_Tag tag;
        OrderBookDelta_t delta;
        QuoteTick_t quote;
        TradeTick_t trade;
        Bar_t bar;

    cdef struct TraderId_t:
        Arc_String *value;

    cdef struct StrategyId_t:
        Arc_String *value;

    cdef struct ClientOrderId_t:
        Arc_String *value;

    cdef struct OrderDenied_t:
        TraderId_t trader_id;
        StrategyId_t strategy_id;
        InstrumentId_t instrument_id;
        ClientOrderId_t client_order_id;
        String *reason;
        UUID4_t event_id;
        uint64_t ts_event;
        uint64_t ts_init;

    cdef struct AccountId_t:
        Arc_String *value;

    cdef struct ClientId_t:
        Arc_String *value;

    cdef struct ComponentId_t:
        Arc_String *value;

    cdef struct ExecAlgorithmId_t:
        Arc_String *value;

    cdef struct OrderListId_t:
        Arc_String *value;

    cdef struct PositionId_t:
        Arc_String *value;

    cdef struct VenueOrderId_t:
        Arc_String *value;

    # Provides a C compatible Foreign Function Interface (FFI) for an underlying
    # [`SyntheticInstrument`].
    #
    # This struct wraps `SyntheticInstrument` in a way that makes it compatible with C function
    # calls, enabling interaction with `SyntheticInstrument` in a C environment.
    #
    # It implements the `Deref` trait, allowing instances of `SyntheticInstrument_API` to be
    # dereferenced to `SyntheticInstrument`, providing access to `SyntheticInstruments`'s methods without
    # having to manually access the underlying instance.
    cdef struct SyntheticInstrument_API:
        SyntheticInstrument *_0;

    # Provides a C compatible Foreign Function Interface (FFI) for an underlying [`OrderBook`].
    #
    # This struct wraps `OrderBook` in a way that makes it compatible with C function
    # calls, enabling interaction with `OrderBook` in a C environment.
    #
    # It implements the `Deref` trait, allowing instances of `OrderBook_API` to be
    # dereferenced to `OrderBook`, providing access to `OrderBook`'s methods without
    # having to manually access the underlying `OrderBook` instance.
    cdef struct OrderBook_API:
        OrderBook *_0;

    cdef struct Currency_t:
        Arc_String *code;
        uint8_t precision;
        uint16_t iso4217;
        Arc_String *name;
        CurrencyType currency_type;

    cdef struct Money_t:
        int64_t raw;
        Currency_t currency;

    # Sentinel Price for errors.
    const Price_t ERROR_PRICE # = <Price_t>{ INT64_MAX, 0 }

    void data_drop(Data_t data);

    Data_t data_clone(const Data_t *data);

    BarSpecification_t bar_specification_new(uint64_t step,
                                             uint8_t aggregation,
                                             uint8_t price_type);

    # Returns a [`BarSpecification`] as a C string pointer.
    const char *bar_specification_to_cstr(const BarSpecification_t *bar_spec);

    uint64_t bar_specification_hash(const BarSpecification_t *bar_spec);

    uint8_t bar_specification_eq(const BarSpecification_t *lhs, const BarSpecification_t *rhs);

    uint8_t bar_specification_lt(const BarSpecification_t *lhs, const BarSpecification_t *rhs);

    uint8_t bar_specification_le(const BarSpecification_t *lhs, const BarSpecification_t *rhs);

    uint8_t bar_specification_gt(const BarSpecification_t *lhs, const BarSpecification_t *rhs);

    uint8_t bar_specification_ge(const BarSpecification_t *lhs, const BarSpecification_t *rhs);

    BarType_t bar_type_new(InstrumentId_t instrument_id,
                           BarSpecification_t spec,
                           uint8_t aggregation_source);

    void bar_type_drop(BarType_t bar_type);

    BarType_t bar_type_clone(const BarType_t *bar_type);

    uint8_t bar_type_eq(const BarType_t *lhs, const BarType_t *rhs);

    uint8_t bar_type_lt(const BarType_t *lhs, const BarType_t *rhs);

    uint8_t bar_type_le(const BarType_t *lhs, const BarType_t *rhs);

    uint8_t bar_type_gt(const BarType_t *lhs, const BarType_t *rhs);

    uint8_t bar_type_ge(const BarType_t *lhs, const BarType_t *rhs);

    uint64_t bar_type_hash(const BarType_t *bar_type);

    # Returns a [`BarType`] as a C string pointer.
    const char *bar_type_to_cstr(const BarType_t *bar_type);

    Bar_t bar_new(BarType_t bar_type,
                  Price_t open,
                  Price_t high,
                  Price_t low,
                  Price_t close,
                  Quantity_t volume,
                  uint64_t ts_event,
                  uint64_t ts_init);

    Bar_t bar_new_from_raw(BarType_t bar_type,
                           int64_t open,
                           int64_t high,
                           int64_t low,
                           int64_t close,
                           uint8_t price_prec,
                           uint64_t volume,
                           uint8_t size_prec,
                           uint64_t ts_event,
                           uint64_t ts_init);

    void bar_drop(Bar_t bar);

    Bar_t bar_clone(const Bar_t *bar);

    uint8_t bar_eq(const Bar_t *lhs, const Bar_t *rhs);

    uint64_t bar_hash(const Bar_t *bar);

    # Returns a [`Bar`] as a C string.
    const char *bar_to_cstr(const Bar_t *bar);

    void orderbook_delta_drop(OrderBookDelta_t delta);

    OrderBookDelta_t orderbook_delta_clone(const OrderBookDelta_t *delta);

    OrderBookDelta_t orderbook_delta_new(InstrumentId_t instrument_id,
                                         BookAction action,
                                         BookOrder_t order,
                                         uint8_t flags,
                                         uint64_t sequence,
                                         uint64_t ts_event,
                                         uint64_t ts_init);

    uint8_t orderbook_delta_eq(const OrderBookDelta_t *lhs, const OrderBookDelta_t *rhs);

    uint64_t orderbook_delta_hash(const OrderBookDelta_t *delta);

    BookOrder_t book_order_from_raw(OrderSide order_side,
                                    int64_t price_raw,
                                    uint8_t price_prec,
                                    uint64_t size_raw,
                                    uint8_t size_prec,
                                    uint64_t order_id);

    uint8_t book_order_eq(const BookOrder_t *lhs, const BookOrder_t *rhs);

    uint64_t book_order_hash(const BookOrder_t *order);

    double book_order_exposure(const BookOrder_t *order);

    double book_order_signed_size(const BookOrder_t *order);

    # Returns a [`BookOrder`] display string as a C string pointer.
    const char *book_order_display_to_cstr(const BookOrder_t *order);

    # Returns a [`BookOrder`] debug string as a C string pointer.
    const char *book_order_debug_to_cstr(const BookOrder_t *order);

    QuoteTick_t quote_tick_new(InstrumentId_t instrument_id,
                               int64_t bid_price_raw,
                               int64_t ask_price_raw,
                               uint8_t bid_price_prec,
                               uint8_t ask_price_prec,
                               uint64_t bid_size_raw,
                               uint64_t ask_size_raw,
                               uint8_t bid_size_prec,
                               uint8_t ask_size_prec,
                               uint64_t ts_event,
                               uint64_t ts_init);

    void quote_tick_drop(QuoteTick_t tick);

    QuoteTick_t quote_tick_clone(const QuoteTick_t *tick);

    uint8_t quote_tick_eq(const QuoteTick_t *lhs, const QuoteTick_t *rhs);

    uint64_t quote_tick_hash(const QuoteTick_t *delta);

    # Returns a [`QuoteTick`] as a C string pointer.
    const char *quote_tick_to_cstr(const QuoteTick_t *tick);

    TradeTick_t trade_tick_new(InstrumentId_t instrument_id,
                               int64_t price_raw,
                               uint8_t price_prec,
                               uint64_t size_raw,
                               uint8_t size_prec,
                               AggressorSide aggressor_side,
                               TradeId_t trade_id,
                               uint64_t ts_event,
                               uint64_t ts_init);

    void trade_tick_drop(TradeTick_t tick);

    TradeTick_t trade_tick_clone(const TradeTick_t *tick);

    uint8_t trade_tick_eq(const TradeTick_t *lhs, const TradeTick_t *rhs);

    uint64_t trade_tick_hash(const TradeTick_t *delta);

    # Returns a [`TradeTick`] as a C string pointer.
    const char *trade_tick_to_cstr(const TradeTick_t *tick);

    const char *account_type_to_cstr(AccountType value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    AccountType account_type_from_cstr(const char *ptr);

    const char *aggregation_source_to_cstr(AggregationSource value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    AggregationSource aggregation_source_from_cstr(const char *ptr);

    const char *aggressor_side_to_cstr(AggressorSide value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    AggressorSide aggressor_side_from_cstr(const char *ptr);

    const char *asset_class_to_cstr(AssetClass value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    AssetClass asset_class_from_cstr(const char *ptr);

    const char *asset_type_to_cstr(AssetType value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    AssetType asset_type_from_cstr(const char *ptr);

    const char *bar_aggregation_to_cstr(uint8_t value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    uint8_t bar_aggregation_from_cstr(const char *ptr);

    const char *book_action_to_cstr(BookAction value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    BookAction book_action_from_cstr(const char *ptr);

    const char *book_type_to_cstr(BookType value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    BookType book_type_from_cstr(const char *ptr);

    const char *contingency_type_to_cstr(ContingencyType value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    ContingencyType contingency_type_from_cstr(const char *ptr);

    const char *currency_type_to_cstr(CurrencyType value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    CurrencyType currency_type_from_cstr(const char *ptr);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    InstrumentCloseType instrument_close_type_from_cstr(const char *ptr);

    const char *instrument_close_type_to_cstr(InstrumentCloseType value);

    const char *liquidity_side_to_cstr(LiquiditySide value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    LiquiditySide liquidity_side_from_cstr(const char *ptr);

    const char *market_status_to_cstr(MarketStatus value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    MarketStatus market_status_from_cstr(const char *ptr);

    const char *oms_type_to_cstr(OmsType value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    OmsType oms_type_from_cstr(const char *ptr);

    const char *option_kind_to_cstr(OptionKind value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    OptionKind option_kind_from_cstr(const char *ptr);

    const char *order_side_to_cstr(OrderSide value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    OrderSide order_side_from_cstr(const char *ptr);

    const char *order_status_to_cstr(OrderStatus value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    OrderStatus order_status_from_cstr(const char *ptr);

    const char *order_type_to_cstr(OrderType value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    OrderType order_type_from_cstr(const char *ptr);

    const char *position_side_to_cstr(PositionSide value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    PositionSide position_side_from_cstr(const char *ptr);

    const char *price_type_to_cstr(PriceType value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    PriceType price_type_from_cstr(const char *ptr);

    const char *time_in_force_to_cstr(TimeInForce value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    TimeInForce time_in_force_from_cstr(const char *ptr);

    const char *trading_state_to_cstr(TradingState value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    TradingState trading_state_from_cstr(const char *ptr);

    const char *trailing_offset_type_to_cstr(TrailingOffsetType value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    TrailingOffsetType trailing_offset_type_from_cstr(const char *ptr);

    const char *trigger_type_to_cstr(TriggerType value);

    # Returns an enum from a Python string.
    #
    # # Safety
    # - Assumes `ptr` is a valid C string pointer.
    TriggerType trigger_type_from_cstr(const char *ptr);

    # # Safety
    #
    # - Assumes `reason_ptr` is a valid C string pointer.
    OrderDenied_t order_denied_new(TraderId_t trader_id,
                                   StrategyId_t strategy_id,
                                   InstrumentId_t instrument_id,
                                   ClientOrderId_t client_order_id,
                                   const char *reason_ptr,
                                   UUID4_t event_id,
                                   uint64_t ts_event,
                                   uint64_t ts_init);

    # Frees the memory for the given `event` by dropping.
    void order_denied_drop(OrderDenied_t event);

    OrderDenied_t order_denied_clone(const OrderDenied_t *event);

    const char *order_denied_reason_to_cstr(const OrderDenied_t *event);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    AccountId_t account_id_new(const char *ptr);

    AccountId_t account_id_clone(const AccountId_t *account_id);

    # Frees the memory for the given `account_id` by dropping.
    void account_id_drop(AccountId_t account_id);

    # Returns an [`AccountId`] as a C string pointer.
    const char *account_id_to_cstr(const AccountId_t *account_id);

    uint8_t account_id_eq(const AccountId_t *lhs, const AccountId_t *rhs);

    uint64_t account_id_hash(const AccountId_t *account_id);

    # Returns a Nautilus identifier from C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    ClientId_t client_id_new(const char *ptr);

    ClientId_t client_id_clone(const ClientId_t *client_id);

    # Frees the memory for the given `client_id` by dropping.
    void client_id_drop(ClientId_t client_id);

    # Returns a [`ClientId`] identifier as a C string pointer.
    const char *client_id_to_cstr(const ClientId_t *client_id);

    uint8_t client_id_eq(const ClientId_t *lhs, const ClientId_t *rhs);

    uint64_t client_id_hash(const ClientId_t *client_id);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    ClientOrderId_t client_order_id_new(const char *ptr);

    ClientOrderId_t client_order_id_clone(const ClientOrderId_t *client_order_id);

    # Frees the memory for the given `client_order_id` by dropping.
    void client_order_id_drop(ClientOrderId_t client_order_id);

    # Returns a [`ClientOrderId`] as a C string pointer.
    const char *client_order_id_to_cstr(const ClientOrderId_t *client_order_id);

    uint8_t client_order_id_eq(const ClientOrderId_t *lhs, const ClientOrderId_t *rhs);

    uint64_t client_order_id_hash(const ClientOrderId_t *client_order_id);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    ComponentId_t component_id_new(const char *ptr);

    ComponentId_t component_id_clone(const ComponentId_t *component_id);

    # Frees the memory for the given `component_id` by dropping.
    void component_id_drop(ComponentId_t component_id);

    # Returns a [`ComponentId`] identifier as a C string pointer.
    const char *component_id_to_cstr(const ComponentId_t *component_id);

    uint8_t component_id_eq(const ComponentId_t *lhs, const ComponentId_t *rhs);

    uint64_t component_id_hash(const ComponentId_t *component_id);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    ExecAlgorithmId_t exec_algorithm_id_new(const char *ptr);

    ExecAlgorithmId_t exec_algorithm_id_clone(const ExecAlgorithmId_t *exec_algorithm_id);

    # Frees the memory for the given `exec_algorithm_id` by dropping.
    void exec_algorithm_id_drop(ExecAlgorithmId_t exec_algorithm_id);

    # Returns an [`ExecAlgorithmId`] identifier as a C string pointer.
    const char *exec_algorithm_id_to_cstr(const ExecAlgorithmId_t *exec_algorithm_id);

    uint8_t exec_algorithm_id_eq(const ExecAlgorithmId_t *lhs, const ExecAlgorithmId_t *rhs);

    uint64_t exec_algorithm_id_hash(const ExecAlgorithmId_t *exec_algorithm_id);

    InstrumentId_t instrument_id_new(const Symbol_t *symbol, const Venue_t *venue);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    InstrumentId_t instrument_id_new_from_cstr(const char *ptr);

    InstrumentId_t instrument_id_clone(const InstrumentId_t *instrument_id);

    # Frees the memory for the given `instrument_id` by dropping.
    void instrument_id_drop(InstrumentId_t instrument_id);

    # Returns an [`InstrumentId`] as a C string pointer.
    const char *instrument_id_to_cstr(const InstrumentId_t *instrument_id);

    uint8_t instrument_id_eq(const InstrumentId_t *lhs, const InstrumentId_t *rhs);

    uint64_t instrument_id_hash(const InstrumentId_t *instrument_id);

    uint8_t instrument_id_is_synthetic(const InstrumentId_t *instrument_id);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    OrderListId_t order_list_id_new(const char *ptr);

    OrderListId_t order_list_id_clone(const OrderListId_t *order_list_id);

    # Frees the memory for the given `order_list_id` by dropping.
    void order_list_id_drop(OrderListId_t order_list_id);

    # Returns an [`OrderListId`] as a C string pointer.
    const char *order_list_id_to_cstr(const OrderListId_t *order_list_id);

    uint8_t order_list_id_eq(const OrderListId_t *lhs, const OrderListId_t *rhs);

    uint64_t order_list_id_hash(const OrderListId_t *order_list_id);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    PositionId_t position_id_new(const char *ptr);

    PositionId_t position_id_clone(const PositionId_t *position_id);

    # Frees the memory for the given `position_id` by dropping.
    void position_id_drop(PositionId_t position_id);

    # Returns a [`PositionId`] identifier as a C string pointer.
    const char *position_id_to_cstr(const PositionId_t *position_id);

    uint8_t position_id_eq(const PositionId_t *lhs, const PositionId_t *rhs);

    uint64_t position_id_hash(const PositionId_t *position_id);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    StrategyId_t strategy_id_new(const char *ptr);

    StrategyId_t strategy_id_clone(const StrategyId_t *strategy_id);

    # Frees the memory for the given `strategy_id` by dropping.
    void strategy_id_drop(StrategyId_t strategy_id);

    # Returns a [`StrategyId`] as a C string pointer.
    const char *strategy_id_to_cstr(const StrategyId_t *strategy_id);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    Symbol_t symbol_new(const char *ptr);

    Symbol_t symbol_clone(const Symbol_t *symbol);

    # Frees the memory for the given [Symbol] by dropping.
    void symbol_drop(Symbol_t symbol);

    # Returns a [`Symbol`] as a C string pointer.
    const char *symbol_to_cstr(const Symbol_t *symbol);

    uint8_t symbol_eq(const Symbol_t *lhs, const Symbol_t *rhs);

    uint64_t symbol_hash(const Symbol_t *symbol);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    TradeId_t trade_id_new(const char *ptr);

    TradeId_t trade_id_clone(const TradeId_t *trade_id);

    # Frees the memory for the given `trade_id` by dropping.
    void trade_id_drop(TradeId_t trade_id);

    # Returns [`TradeId`] as a C string pointer.
    const char *trade_id_to_cstr(const TradeId_t *trade_id);

    uint8_t trade_id_eq(const TradeId_t *lhs, const TradeId_t *rhs);

    uint64_t trade_id_hash(const TradeId_t *trade_id);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    TraderId_t trader_id_new(const char *ptr);

    TraderId_t trader_id_clone(const TraderId_t *trader_id);

    # Frees the memory for the given `trader_id` by dropping.
    void trader_id_drop(TraderId_t trader_id);

    # Returns a [`TraderId`] as a C string pointer.
    const char *trader_id_to_cstr(const TraderId_t *trader_id);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    Venue_t venue_new(const char *ptr);

    Venue_t venue_clone(const Venue_t *venue);

    # Frees the memory for the given `venue` by dropping.
    void venue_drop(Venue_t venue);

    # Returns a [`Venue`] identifier as a C string pointer.
    const char *venue_to_cstr(const Venue_t *venue);

    uint8_t venue_eq(const Venue_t *lhs, const Venue_t *rhs);

    uint64_t venue_hash(const Venue_t *venue);

    uint8_t venue_is_synthetic(const Venue_t *venue);

    # Returns a Nautilus identifier from a C string pointer.
    #
    # # Safety
    #
    # - Assumes `ptr` is a valid C string pointer.
    VenueOrderId_t venue_order_id_new(const char *ptr);

    VenueOrderId_t venue_order_id_clone(const VenueOrderId_t *venue_order_id);

    # Frees the memory for the given `venue_order_id` by dropping.
    void venue_order_id_drop(VenueOrderId_t venue_order_id);

    const char *venue_order_id_to_cstr(const VenueOrderId_t *venue_order_id);

    uint8_t venue_order_id_eq(const VenueOrderId_t *lhs, const VenueOrderId_t *rhs);

    uint64_t venue_order_id_hash(const VenueOrderId_t *venue_order_id);

    # # Safety
    #
    # - Assumes `components_ptr` is a valid C string pointer of a JSON format list of strings.
    # - Assumes `formula_ptr` is a valid C string pointer.
    SyntheticInstrument_API synthetic_instrument_new(Symbol_t symbol,
                                                     uint8_t price_precision,
                                                     const char *components_ptr,
                                                     const char *formula_ptr,
                                                     uint64_t ts_event,
                                                     uint64_t ts_init);

    void synthetic_instrument_drop(SyntheticInstrument_API synth);

    InstrumentId_t synthetic_instrument_id(const SyntheticInstrument_API *synth);

    uint8_t synthetic_instrument_price_precision(const SyntheticInstrument_API *synth);

    Price_t synthetic_instrument_price_increment(const SyntheticInstrument_API *synth);

    const char *synthetic_instrument_formula_to_cstr(const SyntheticInstrument_API *synth);

    const char *synthetic_instrument_components_to_cstr(const SyntheticInstrument_API *synth);

    uintptr_t synthetic_instrument_components_count(const SyntheticInstrument_API *synth);

    uint64_t synthetic_instrument_ts_event(const SyntheticInstrument_API *synth);

    uint64_t synthetic_instrument_ts_init(const SyntheticInstrument_API *synth);

    # # Safety
    #
    # - Assumes `formula_ptr` is a valid C string pointer.
    uint8_t synthetic_instrument_is_valid_formula(const SyntheticInstrument_API *synth,
                                                  const char *formula_ptr);

    # # Safety
    #
    # - Assumes `formula_ptr` is a valid C string pointer.
    void synthetic_instrument_change_formula(SyntheticInstrument_API *synth,
                                             const char *formula_ptr);

    Price_t synthetic_instrument_calculate(SyntheticInstrument_API *synth, const CVec *inputs_ptr);

    OrderBook_API orderbook_new(InstrumentId_t instrument_id, BookType book_type);

    void orderbook_drop(OrderBook_API book);

    void orderbook_reset(OrderBook_API *book);

    InstrumentId_t orderbook_instrument_id(const OrderBook_API *book);

    BookType orderbook_book_type(const OrderBook_API *book);

    uint64_t orderbook_sequence(const OrderBook_API *book);

    uint64_t orderbook_ts_last(const OrderBook_API *book);

    uint64_t orderbook_count(const OrderBook_API *book);

    void orderbook_add(OrderBook_API *book,
                       BookOrder_t order,
                       uint64_t ts_event,
                       uint64_t sequence);

    void orderbook_update(OrderBook_API *book,
                          BookOrder_t order,
                          uint64_t ts_event,
                          uint64_t sequence);

    void orderbook_delete(OrderBook_API *book,
                          BookOrder_t order,
                          uint64_t ts_event,
                          uint64_t sequence);

    void orderbook_clear(OrderBook_API *book, uint64_t ts_event, uint64_t sequence);

    void orderbook_clear_bids(OrderBook_API *book, uint64_t ts_event, uint64_t sequence);

    void orderbook_clear_asks(OrderBook_API *book, uint64_t ts_event, uint64_t sequence);

    void orderbook_apply_delta(OrderBook_API *book, OrderBookDelta_t delta);

    uint8_t orderbook_has_bid(OrderBook_API *book);

    uint8_t orderbook_has_ask(OrderBook_API *book);

    Price_t orderbook_best_bid_price(OrderBook_API *book);

    Price_t orderbook_best_ask_price(OrderBook_API *book);

    Quantity_t orderbook_best_bid_size(OrderBook_API *book);

    Quantity_t orderbook_best_ask_size(OrderBook_API *book);

    double orderbook_spread(OrderBook_API *book);

    double orderbook_midpoint(OrderBook_API *book);

    double orderbook_get_avg_px_for_quantity(OrderBook_API *book,
                                             Quantity_t qty,
                                             OrderSide order_side);

    void orderbook_update_quote_tick(OrderBook_API *book, const QuoteTick_t *tick);

    void orderbook_update_trade_tick(OrderBook_API *book, const TradeTick_t *tick);

    CVec orderbook_simulate_fills(const OrderBook_API *book, BookOrder_t order);

    void orderbook_check_integrity(const OrderBook_API *book);

    void vec_fills_drop(CVec v);

    # Returns a pretty printed [`OrderBook`] number of levels per side, as a C string pointer.
    const char *orderbook_pprint_to_cstr(const OrderBook_API *book, uintptr_t num_levels);

    # Returns a [`Currency`] from pointers and primitives.
    #
    # # Safety
    #
    # - Assumes `code_ptr` is a valid C string pointer.
    # - Assumes `name_ptr` is a valid C string pointer.
    Currency_t currency_from_py(const char *code_ptr,
                                uint8_t precision,
                                uint16_t iso4217,
                                const char *name_ptr,
                                CurrencyType currency_type);

    Currency_t currency_clone(const Currency_t *currency);

    void currency_drop(Currency_t currency);

    const char *currency_to_cstr(const Currency_t *currency);

    const char *currency_code_to_cstr(const Currency_t *currency);

    const char *currency_name_to_cstr(const Currency_t *currency);

    uint8_t currency_eq(const Currency_t *lhs, const Currency_t *rhs);

    uint64_t currency_hash(const Currency_t *currency);

    void currency_register(Currency_t currency);

    # # Safety
    #
    # - Assumes `code_ptr` is borrowed from a valid Python UTF-8 `str`.
    uint8_t currency_exists(const char *code_ptr);

    # # Safety
    #
    # - Assumes `code_ptr` is borrowed from a valid Python UTF-8 `str`.
    Currency_t currency_from_cstr(const char *code_ptr);

    Money_t money_new(double amount, Currency_t currency);

    Money_t money_from_raw(int64_t raw, Currency_t currency);

    void money_drop(Money_t money);

    double money_as_f64(const Money_t *money);

    void money_add_assign(Money_t a, Money_t b);

    void money_sub_assign(Money_t a, Money_t b);

    Price_t price_new(double value, uint8_t precision);

    Price_t price_from_raw(int64_t raw, uint8_t precision);

    double price_as_f64(const Price_t *price);

    void price_add_assign(Price_t a, Price_t b);

    void price_sub_assign(Price_t a, Price_t b);

    Quantity_t quantity_new(double value, uint8_t precision);

    Quantity_t quantity_from_raw(uint64_t raw, uint8_t precision);

    double quantity_as_f64(const Quantity_t *qty);

    void quantity_add_assign(Quantity_t a, Quantity_t b);

    void quantity_add_assign_u64(Quantity_t a, uint64_t b);

    void quantity_sub_assign(Quantity_t a, Quantity_t b);

    void quantity_sub_assign_u64(Quantity_t a, uint64_t b);
