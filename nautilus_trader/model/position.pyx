# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2020 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import numpy as np

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.decimal cimport Decimal
from nautilus_trader.model.c_enums.order_side cimport OrderSide
from nautilus_trader.model.c_enums.position_side cimport PositionSide
from nautilus_trader.model.c_enums.position_side cimport position_side_to_string
from nautilus_trader.model.events cimport OrderFilled
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.tick cimport QuoteTick


# noinspection: Object has warned attribute
# noinspection PyUnresolvedReferences
cdef class Position:
    """
    Represents a position in a financial market.
    """

    def __init__(self, OrderFilled event not None):
        """
        Initialize a new instance of the `Position` class.

        Parameters
        ----------
        event : OrderFillEvent
            The order fill event which opened the position.

        """
        self._events = []                    # type: [OrderFilled]
        self._buy_quantity = Quantity()      # Initialized in apply()
        self._sell_quantity = Quantity()     # Initialized in apply()
        self._relative_quantity = Decimal()  # Initialized in apply()

        # Identifiers
        self._id = event.position_id
        self._account_id = event.account_id
        self._from_order = event.cl_ord_id
        self._strategy_id = event.strategy_id

        # Properties
        self._symbol = event.symbol
        self._entry = event.order_side
        self._side = PositionSide.UNDEFINED  # Initialized in apply()
        self._quantity = Quantity()          # Initialized in apply()
        self._peak_quantity = Quantity()     # Initialized in apply()
        self._base_currency = event.base_currency
        self._quote_currency = event.quote_currency
        self._timestamp = event.execution_time
        self._opened_time = event.execution_time
        self._closed_time = None    # Can be none
        self._open_duration = None  # Can be none
        self._avg_open = Decimal(event.avg_price)
        self._avg_close = Decimal()
        self._realized_points = Decimal()
        self._realized_return = Decimal()
        self._realized_pnl = Money(0, event.base_currency)
        self._commission = Money(0, event.base_currency)

        self.apply(event)

    def __eq__(self, Position other) -> bool:
        return self._id == other.id

    def __ne__(self, Position other) -> bool:
        return self._id != other.id

    def __hash__(self) -> int:
        return hash(self._id.value)

    def __repr__(self) -> str:
        return f"{type(self).__name__}(id={self._id.value}, {self.status_string()})"

    @property
    def id(self):
        """
        The positions identifier.

        This may be generated by the exchange/brokerage, or can be system
        generated depending on `Order Management System (OMS)` settings.

        Returns
        -------
        PositionId

        """
        return self._id

    @property
    def account_id(self):
        """
        The account identifier associated with the position.

        Returns
        -------
        PositionId

        """
        return self._account_id

    @property
    def from_order(self):
        """
        The client order identifier for the order which first opened the position.

        Returns
        -------
        ClientOrderId

        """
        return self._from_order

    @property
    def strategy_id(self):
        """
        The strategy identifier associated with the position.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def timestamp(self):
        """
        The positions initialization timestamp.

        Returns
        -------
        datetime

        """
        return self._timestamp

    @property
    def symbol(self):
        """
        The positions symbol.

        Returns
        -------
        Symbol

        """
        return self._symbol

    @property
    def entry(self):
        """
        The positions entry direction from open.

        Returns
        -------
        OrderSide

        """
        return self._entry

    @property
    def side(self):
        """
        The positions current side.

        Returns
        -------
        PositionSide

        """
        return self._side

    @property
    def quantity(self):
        """
        The positions current open quantity.

        Returns
        -------
        Quantity

        """
        return self._quantity

    @property
    def peak_quantity(self):
        """
        The peak directional quantity reached by the position.

        Returns
        -------
        Quantity

        """
        return self._peak_quantity

    @property
    def base_currency(self):
        """
        The base currency of the positions instrument.

        Returns
        -------
        Currency

        """
        return self._base_currency

    @property
    def quote_currency(self):
        """
        The quote currency of the positions instrument.

        Returns
        -------
        Currency

        """
        return self._quote_currency

    @property
    def opened_time(self):
        """
        The positions opened time.

        Returns
        -------
        datetime

        """
        return self._opened_time

    @property
    def closed_time(self):
        """
        The positions closed time.

        Returns
        -------
        datetime or None
            If the position side is not FLAT, then will return None.

        """
        return self._closed_time

    @property
    def open_duration(self):
        """
        The s total open duration.

        Returns
        -------
        timedelta or None
            If the position side is not FLAT, then will return None.

        """
        return self._open_duration

    @property
    def avg_open(self):
        """
        The positions average open price.

        Returns
        -------
        Decimal

        """
        return self._avg_open

    @property
    def avg_close(self):
        """
        The positions average closing price.

        Returns
        -------
        Decimal or None

        """
        return self._avg_close

    @property
    def realized_points(self):
        """
        The realized points of the position.

        Returns
        -------
        Decimal

        """
        return self._realized_points

    @property
    def realized_return(self):
        """
        The realized return of the position.

        Returns
        -------
        Decimal

        """
        return self._realized_return

    @property
    def realized_pnl(self):
        """
        The realized pnl of the position.

        Returns
        -------
        Money

        """
        return self._realized_pnl

    @property
    def commission(self):
        """
        The commission generated on the position.

        Returns
        -------
        Money

        """
        return self._commission

    @property
    def cl_ord_ids(self):
        """
        The client order identifiers associated with the position.

        Returns
        -------
        list[OrderId]

        Notes
        -----
        Guaranteed not to contain duplicate identifiers.

        """
        cdef OrderFilled event
        return np.unique([event.cl_ord_id for event in self._events]).tolist()

    @property
    def order_ids(self):
        """
        The order identifiers associated with the position.

        Returns
        -------
        list[OrderId]

        Notes
        -----
        Guaranteed not to contain duplicate identifiers.

        """
        cdef OrderFilled event
        return np.unique([event.order_id for event in self._events]).tolist()

    @property
    def execution_ids(self):
        """
        The execution identifiers associated with the position.

        Returns
        -------
        list[ExecutionId]

        Notes
        -----
        Assumption that all `ExecutionId`s were, unique, so the list
        may contain duplicates.

        """
        cdef OrderFilled event
        return [event.execution_id for event in self._events]

    @property
    def events(self):
        """
        The order fill events of the position.

        Returns
        -------
        list[Event]

        """
        return self._events.copy()

    @property
    def last_event(self):
        """
        The last order fill event.

        Returns
        -------
        OrderFilled

        """
        return self._events[-1]

    @property
    def last_execution_id(self):
        """
        The last execution identifier for the position.

        Returns
        -------
        ExecutionId

        """
        return self._events[-1].execution_id

    @property
    def event_count(self):
        """
        The count of order fill events applied to the position.

        Returns
        -------
        int

        """
        return len(self._events)

    @property
    def is_open(self):
        """
        If the position side is not `FLAT`.

        Returns
        -------
        bool
            True if FLAT, else False.

        """
        return self._side != PositionSide.FLAT

    @property
    def is_closed(self):
        """
        If the position side is `FLAT`.

        Returns
        -------
        bool
            True if not FLAT, else False.

        """
        return self._side == PositionSide.FLAT

    @property
    def is_long(self):
        """
        If the position side is `LONG`.

        Returns
        -------
        bool
            True if LONG, else False.

        """
        return self._side == PositionSide.LONG

    @property
    def is_short(self):
        """
        If the position side is short.

        Returns
        -------
        bool
            True if SHORT, else False.

        """
        return self._side == PositionSide.SHORT

    @property
    def relative_quantity(self):
        """
        Return the relative quantity of the position.

        Returns
        -------
        Decimal
            Positive values for long, negative values for short.

        """
        return self._relative_quantity

    @staticmethod
    cdef inline PositionSide side_from_order_side_c(OrderSide side) except *:
        """
        Return the position side resulting from the given order side (from FLAT).

        Parameters
        ----------
        side : OrderSide
            The order side

        Returns
        -------
        PositionSide

        Raises
        ------
        ValueError
            If side is UNDEFINED.

        """
        Condition.not_equal(side, OrderSide.UNDEFINED, "side", "UNDEFINED")

        return PositionSide.LONG if side == OrderSide.BUY else PositionSide.SHORT

    @staticmethod
    def side_from_order_side(OrderSide side):
        """
        Return the position side resulting from the given order side (from FLAT).

        Parameters
        ----------
        side : OrderSide
            The order side

        Returns
        -------
        PositionSide

        Raises
        ------
        ValueError
            If side is UNDEFINED.

        """
        return Position.side_from_order_side_c(side)

    cpdef void apply(self, OrderFilled event) except *:
        """
        Applies the given order fill event to the position.

        Parameters
        ----------
        event : OrderFillEvent
            The order fill event to apply.

        """
        Condition.not_none(event, "event")

        self._events.append(event)

        # Update total commission
        self._commission = Money(self._commission + event.commission, self._commission.currency)

        # Calculate avg prices, points, return, PNL
        if event.order_side == OrderSide.BUY:
            self._handle_buy_order_fill(event)
        else:  # event.order_side == OrderSide.SELL:
            self._handle_sell_order_fill(event)

        # Set quantities
        self._quantity = Quantity(abs(self._relative_quantity))
        if self._quantity > self._peak_quantity:
            self._peak_quantity = self._quantity

        # Set state
        if self._relative_quantity > 0:
            self._side = PositionSide.LONG
        elif self._relative_quantity < 0:
            self._side = PositionSide.SHORT
        else:
            self._side = PositionSide.FLAT
            self._closed_time = event.execution_time
            self._open_duration = self._closed_time - self._opened_time

    cdef str status_string(self):
        """
        Return the positions status as a string.

        Returns
        -------
        str

        """
        cdef str quantity = " " if self._relative_quantity == 0 else f" {self._quantity.to_string()} "
        return f"{position_side_to_string(self._side)}{quantity}{self._symbol}"

    cpdef Money unrealized_pnl(self, QuoteTick last):
        """
        Return the unrealized PNL from the given last quote tick.

        Parameters
        ----------
        last : QuoteTick
            The last tick for the calculation.

        Returns
        -------
        Money

        """
        Condition.not_none(last, "last")

        if self._side == PositionSide.LONG:
            return self._calculate_pnl(self._avg_open, last.bid, self._quantity)
        elif self._side == PositionSide.SHORT:
            return self._calculate_pnl(self._avg_open, last.ask, self._quantity)
        else:
            return Money(0, self._base_currency)

    cpdef Money total_pnl(self, QuoteTick last):
        """
        Return the total PNL from the given last quote tick.

        Parameters
        ----------
        last : QuoteTick
            The last tick for the calculation.

        Returns
        -------
        Money

        """
        Condition.not_none(last, "last")

        return Money(self._realized_pnl + self.unrealized_pnl(last), self._base_currency)

    cdef inline void _handle_buy_order_fill(self, OrderFilled event) except *:
        cdef Money realized_pnl = event.commission
        # LONG POSITION
        if self._relative_quantity > 0:
            self._avg_open = self._calculate_avg_open_price(event)
        # SHORT POSITION
        elif self._relative_quantity < 0:
            self._avg_close = self._calculate_avg_close_price(event)
            self._realized_points = self._calculate_points(self._avg_open, self._avg_close)
            self._realized_return = self._calculate_return(self._avg_open, self._avg_close)
            realized_pnl = self._calculate_pnl(self._avg_open, event.avg_price, event.filled_qty)

        self._realized_pnl = Money(self._realized_pnl + realized_pnl, self._base_currency)

        # Update quantities
        self._buy_quantity = Quantity(self._buy_quantity + event.filled_qty)
        self._relative_quantity = Decimal(self._relative_quantity + event.filled_qty)

    cdef inline void _handle_sell_order_fill(self, OrderFilled event) except *:
        cdef Money realized_pnl = event.commission
        # SHORT POSITION
        if self._relative_quantity < 0:
            self._avg_open = Decimal(self._calculate_avg_open_price(event))
        # LONG POSITION
        elif self._relative_quantity > 0:
            self._avg_close = self._calculate_avg_close_price(event)
            self._realized_points = self._calculate_points(self._avg_open, self._avg_close)
            self._realized_return = self._calculate_return(self._avg_open, self._avg_close)
            realized_pnl = self._calculate_pnl(self._avg_open, event.avg_price, event.filled_qty)

        self._realized_pnl = Money(self._realized_pnl + realized_pnl, self._base_currency)

        # Update quantities
        self._sell_quantity = Quantity(self._sell_quantity + event.filled_qty)
        self._relative_quantity = Decimal(self._relative_quantity - event.filled_qty)

    cdef inline Decimal _calculate_cost(self, Decimal avg_price, Quantity total_quantity):
        return avg_price * total_quantity

    cdef inline Decimal _calculate_avg_open_price(self, OrderFilled event):
        if not self._avg_open:
            return event.avg_price

        return self._calculate_avg_price(self._avg_open, self._quantity, event)

    cdef inline Decimal _calculate_avg_close_price(self, OrderFilled event):
        if not self._avg_close:
            return event.avg_price

        cdef Quantity close_quantity = Quantity(self._sell_quantity) if self._side == PositionSide.LONG else self._buy_quantity
        return self._calculate_avg_price(self._avg_close, close_quantity, event)

    cdef inline Decimal _calculate_avg_price(
        self,
        Decimal open_price,
        Quantity open_quantity,
        OrderFilled event,
    ):
        cdef Decimal start_cost = self._calculate_cost(open_price, open_quantity)
        cdef Decimal event_cost = self._calculate_cost(event.avg_price, event.filled_qty)
        cdef Decimal cumulative_quantity = open_quantity + event.filled_qty
        return (start_cost + event_cost) / cumulative_quantity

    cdef inline Decimal _calculate_points(self, Decimal open_price, Decimal close_price):
        if self._side == PositionSide.LONG:
            return close_price - open_price
        elif self._side == PositionSide.SHORT:
            return open_price - close_price
        else:
            return Decimal()  # FLAT

    cdef inline Decimal _calculate_return(self, Decimal open_price, Decimal close_price):
        if self._side == PositionSide.LONG:
            return (close_price - open_price) / open_price
        elif self._side == PositionSide.SHORT:
            return (open_price - close_price) / open_price
        else:
            return Decimal()  # FLAT

    cdef inline Money _calculate_pnl(
        self,
        Decimal open_price,
        Decimal close_price,
        Quantity filled_qty,
    ):
        return Money(
            self._calculate_return(open_price, close_price) * filled_qty,
            self._base_currency,
        )
