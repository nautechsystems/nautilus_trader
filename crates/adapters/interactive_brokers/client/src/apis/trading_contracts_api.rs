/*
 * IB REST API
 *
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.15.0
 * Contact: api@interactivebrokers.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`iserver_contract_conid_algos_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverContractConidAlgosGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_contract_conid_info_and_rules_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverContractConidInfoAndRulesGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_contract_conid_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverContractConidInfoGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_contract_rules_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverContractRulesPostError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_currency_pairs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverCurrencyPairsGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_exchangerate_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverExchangerateGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_secdef_bond_filters_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverSecdefBondFiltersGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_secdef_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverSecdefInfoGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_secdef_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverSecdefSearchGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_secdef_search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverSecdefSearchPostError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_secdef_strikes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverSecdefStrikesGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trsrv_all_conids_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrsrvAllConidsGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trsrv_futures_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrsrvFuturesGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trsrv_secdef_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrsrvSecdefGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trsrv_secdef_schedule_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrsrvSecdefScheduleGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trsrv_stocks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrsrvStocksGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// Returns supported IB Algos for contract. A pre-flight request must be submitted before retrieving information
pub async fn iserver_contract_conid_algos_get(
    configuration: &configuration::Configuration,
    conid: &str,
    algos: Option<&str>,
    add_description: Option<&str>,
    add_params: Option<&str>,
) -> Result<models::AlgosResponse, Error<IserverContractConidAlgosGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_conid = conid;
    let p_algos = algos;
    let p_add_description = add_description;
    let p_add_params = add_params;

    let uri_str = format!(
        "{}/iserver/contract/{conid}/algos",
        configuration.base_path,
        conid = crate::apis::urlencode(p_conid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_algos {
        req_builder = req_builder.query(&[("algos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_add_description {
        req_builder = req_builder.query(&[("addDescription", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_add_params {
        req_builder = req_builder.query(&[("addParams", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AlgosResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AlgosResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverContractConidAlgosGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Requests full contract details for the given conid.
pub async fn iserver_contract_conid_info_and_rules_get(
    configuration: &configuration::Configuration,
    conid: &str,
) -> Result<
    models::IserverContractConidInfoAndRulesGet200Response,
    Error<IserverContractConidInfoAndRulesGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_conid = conid;

    let uri_str = format!(
        "{}/iserver/contract/{conid}/info-and-rules",
        configuration.base_path,
        conid = crate::apis::urlencode(p_conid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IserverContractConidInfoAndRulesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IserverContractConidInfoAndRulesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverContractConidInfoAndRulesGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Requests full contract details for the given conid.
pub async fn iserver_contract_conid_info_get(
    configuration: &configuration::Configuration,
    conid: &str,
) -> Result<models::ContractInfo, Error<IserverContractConidInfoGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_conid = conid;

    let uri_str = format!(
        "{}/iserver/contract/{conid}/info",
        configuration.base_path,
        conid = crate::apis::urlencode(p_conid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContractInfo`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContractInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverContractConidInfoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns trading related rules for a specific contract and side.
pub async fn iserver_contract_rules_post(
    configuration: &configuration::Configuration,
    iserver_contract_rules_post_request: models::IserverContractRulesPostRequest,
) -> Result<models::ContractRules, Error<IserverContractRulesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_iserver_contract_rules_post_request = iserver_contract_rules_post_request;

    let uri_str = format!("{}/iserver/contract/rules", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_iserver_contract_rules_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContractRules`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContractRules`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverContractRulesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Obtains available currency pairs corresponding to the given target currency.
pub async fn iserver_currency_pairs_get(
    configuration: &configuration::Configuration,
    currency: &str,
) -> Result<
    std::collections::HashMap<String, Vec<models::CurrencyPairsValueInner>>,
    Error<IserverCurrencyPairsGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_currency = currency;

    let uri_str = format!("{}/iserver/currency/pairs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("currency", &p_currency.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, Vec&lt;models::CurrencyPairsValueInner&gt;&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, Vec&lt;models::CurrencyPairsValueInner&gt;&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverCurrencyPairsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Obtains the exchange rates of the currency pair.
pub async fn iserver_exchangerate_get(
    configuration: &configuration::Configuration,
    target: &str,
    source: &str,
) -> Result<models::IserverExchangerateGet200Response, Error<IserverExchangerateGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_target = target;
    let p_source = source;

    let uri_str = format!("{}/iserver/exchangerate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("target", &p_target.to_string())]);
    req_builder = req_builder.query(&[("source", &p_source.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IserverExchangerateGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IserverExchangerateGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverExchangerateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Request a list of filters relating to a given Bond issuerID. The issuerId is retrieved from /iserver/secdef/search and can be used in /iserver/secdef/info?issuerId={issuerId} for retrieving conIds.
pub async fn iserver_secdef_bond_filters_get(
    configuration: &configuration::Configuration,
    symbol: &str,
    issue_id: &str,
) -> Result<models::BondFiltersResponse, Error<IserverSecdefBondFiltersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_issue_id = issue_id;

    let uri_str = format!("{}/iserver/secdef/bond-filters", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    req_builder = req_builder.query(&[("issueId", &p_issue_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BondFiltersResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BondFiltersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverSecdefBondFiltersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SecDef info
pub async fn iserver_secdef_info_get(
    configuration: &configuration::Configuration,
    conid: Option<&str>,
    sectype: Option<serde_json::Value>,
    month: Option<serde_json::Value>,
    exchange: Option<serde_json::Value>,
    strike: Option<serde_json::Value>,
    right: Option<&str>,
    issuer_id: Option<&str>,
    filters: Option<serde_json::Value>,
) -> Result<models::SecDefInfoResponse, Error<IserverSecdefInfoGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_conid = conid;
    let p_sectype = sectype;
    let p_month = month;
    let p_exchange = exchange;
    let p_strike = strike;
    let p_right = right;
    let p_issuer_id = issuer_id;
    let p_filters = filters;

    let uri_str = format!("{}/iserver/secdef/info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_conid {
        req_builder = req_builder.query(&[("conid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sectype {
        req_builder = req_builder.query(&[("sectype", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_month {
        req_builder = req_builder.query(&[("month", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_strike {
        req_builder = req_builder.query(&[("strike", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_right {
        req_builder = req_builder.query(&[("right", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_issuer_id {
        req_builder = req_builder.query(&[("issuerId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filters {
        req_builder = req_builder.query(&[("filters", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SecDefInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SecDefInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverSecdefInfoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of contracts based on the search symbol provided as a query param.
pub async fn iserver_secdef_search_get(
    configuration: &configuration::Configuration,
    symbol: Option<&str>,
    sec_type: Option<&str>,
    name: Option<bool>,
    more: Option<bool>,
    fund: Option<bool>,
    fund_family_conid_ex: Option<&str>,
    pattern: Option<bool>,
    referrer: Option<&str>,
) -> Result<Vec<models::SecdefSearchResponseInner>, Error<IserverSecdefSearchGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbol = symbol;
    let p_sec_type = sec_type;
    let p_name = name;
    let p_more = more;
    let p_fund = fund;
    let p_fund_family_conid_ex = fund_family_conid_ex;
    let p_pattern = pattern;
    let p_referrer = referrer;

    let uri_str = format!("{}/iserver/secdef/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_symbol {
        req_builder = req_builder.query(&[("symbol", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sec_type {
        req_builder = req_builder.query(&[("secType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_more {
        req_builder = req_builder.query(&[("more", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fund {
        req_builder = req_builder.query(&[("fund", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fund_family_conid_ex {
        req_builder = req_builder.query(&[("fundFamilyConidEx", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pattern {
        req_builder = req_builder.query(&[("pattern", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_referrer {
        req_builder = req_builder.query(&[("referrer", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SecdefSearchResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SecdefSearchResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverSecdefSearchGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of contracts based on the search symbol provided as a query param.
pub async fn iserver_secdef_search_post(
    configuration: &configuration::Configuration,
    iserver_secdef_search_post_request: models::IserverSecdefSearchPostRequest,
) -> Result<Vec<models::SecdefSearchResponseInner>, Error<IserverSecdefSearchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_iserver_secdef_search_post_request = iserver_secdef_search_post_request;

    let uri_str = format!("{}/iserver/secdef/search", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_iserver_secdef_search_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SecdefSearchResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SecdefSearchResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverSecdefSearchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// strikes
pub async fn iserver_secdef_strikes_get(
    configuration: &configuration::Configuration,
    conid: &str,
    sectype: &str,
    month: &str,
    exchange: Option<&str>,
) -> Result<models::IserverSecdefStrikesGet200Response, Error<IserverSecdefStrikesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_conid = conid;
    let p_sectype = sectype;
    let p_month = month;
    let p_exchange = exchange;

    let uri_str = format!("{}/iserver/secdef/strikes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("conid", &p_conid.to_string())]);
    req_builder = req_builder.query(&[("sectype", &p_sectype.to_string())]);
    req_builder = req_builder.query(&[("month", &p_month.to_string())]);
    if let Some(ref param_value) = p_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IserverSecdefStrikesGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IserverSecdefStrikesGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverSecdefStrikesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Send out a request to retrieve all contracts made available on a requested exchange. This returns all contracts that are tradable on the exchange, even those that are not using the exchange as their primary listing.
pub async fn trsrv_all_conids_get(
    configuration: &configuration::Configuration,
    exchange: &str,
    asset_class: Option<serde_json::Value>,
) -> Result<Vec<models::TrsrvAllConidsGet200ResponseInner>, Error<TrsrvAllConidsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_exchange = exchange;
    let p_asset_class = asset_class;

    let uri_str = format!("{}/trsrv/all-conids", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("exchange", &p_exchange.to_string())]);
    if let Some(ref param_value) = p_asset_class {
        req_builder = req_builder.query(&[("assetClass", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TrsrvAllConidsGet200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TrsrvAllConidsGet200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TrsrvAllConidsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of non-expired future contracts for given symbol(s)
pub async fn trsrv_futures_get(
    configuration: &configuration::Configuration,
    symbols: &str,
    exchange: Option<serde_json::Value>,
) -> Result<models::Features, Error<TrsrvFuturesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbols = symbols;
    let p_exchange = exchange;

    let uri_str = format!("{}/trsrv/futures", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("symbols", &p_symbols.to_string())]);
    if let Some(ref param_value) = p_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Features`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Features`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TrsrvFuturesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of security definitions for the given conids.
pub async fn trsrv_secdef_get(
    configuration: &configuration::Configuration,
    conids: &str,
    criteria: Option<String>,
    bondp: Option<String>,
) -> Result<models::TrsrvSecDefResponse, Error<TrsrvSecdefGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_conids = conids;
    let p_criteria = criteria;
    let p_bondp = bondp;

    let uri_str = format!("{}/trsrv/secdef", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("conids", &p_conids.to_string())]);
    if let Some(ref param_value) = p_criteria {
        req_builder = req_builder.query(&[("criteria", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_bondp {
        req_builder = req_builder.query(&[("bondp", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrsrvSecDefResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrsrvSecDefResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TrsrvSecdefGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the trading schedule up to a month for the requested contract.
pub async fn trsrv_secdef_schedule_get(
    configuration: &configuration::Configuration,
    asset_class: &str,
    symbol: &str,
    exchange: Option<&str>,
    exchange_filter: Option<&str>,
) -> Result<Vec<models::TradingScheduleInner>, Error<TrsrvSecdefScheduleGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asset_class = asset_class;
    let p_symbol = symbol;
    let p_exchange = exchange;
    let p_exchange_filter = exchange_filter;

    let uri_str = format!("{}/trsrv/secdef/schedule", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("assetClass", &p_asset_class.to_string())]);
    req_builder = req_builder.query(&[("symbol", &p_symbol.to_string())]);
    if let Some(ref param_value) = p_exchange {
        req_builder = req_builder.query(&[("exchange", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exchange_filter {
        req_builder = req_builder.query(&[("exchangeFilter", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TradingScheduleInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TradingScheduleInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TrsrvSecdefScheduleGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns an object contains all stock contracts for given symbol(s)
pub async fn trsrv_stocks_get(
    configuration: &configuration::Configuration,
    symbols: &str,
) -> Result<
    std::collections::HashMap<String, Vec<models::StocksValueInner>>,
    Error<TrsrvStocksGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_symbols = symbols;

    let uri_str = format!("{}/trsrv/stocks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("symbols", &p_symbols.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, Vec&lt;models::StocksValueInner&gt;&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, Vec&lt;models::StocksValueInner&gt;&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TrsrvStocksGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
