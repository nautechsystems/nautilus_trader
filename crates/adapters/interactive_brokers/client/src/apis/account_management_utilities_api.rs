/*
 * IB REST API
 *
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.15.0
 * Contact: api@interactivebrokers.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`gw_api_v1_enumerations_complex_asset_transfer_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GwApiV1EnumerationsComplexAssetTransferGetError {
    Status400(models::NoSuchInstructionResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gw_api_v1_enumerations_enumeration_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GwApiV1EnumerationsEnumerationTypeGetError {
    Status500(models::ProblemDetailResponse),
    Status403(models::ProblemDetailResponse),
    Status415(std::collections::HashMap<String, serde_json::Value>),
    Status400(models::ProblemDetailResponse),
    Status401(models::ProblemDetailResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gw_api_v1_fee_templates_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GwApiV1FeeTemplatesPostError {
    Status400(models::MissingRequiredParameterResponse),
    Status403(models::ForbiddenInstructionResponse),
    Status422(models::BusinessRejectResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gw_api_v1_fee_templates_query_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GwApiV1FeeTemplatesQueryPostError {
    Status400(models::MissingRequiredParameterResponse),
    Status403(models::ForbiddenInstructionResponse),
    Status422(models::BusinessRejectResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gw_api_v1_forms_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GwApiV1FormsGetError {
    Status500(models::ProblemDetailResponse),
    Status403(models::ProblemDetailResponse),
    Status415(std::collections::HashMap<String, serde_json::Value>),
    Status400(models::ProblemDetailResponse),
    Status401(models::ProblemDetailResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gw_api_v1_participating_banks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GwApiV1ParticipatingBanksGetError {
    Status400(models::NoSuchInstructionResponse),
    Status500(models::InternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gw_api_v1_requests_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GwApiV1RequestsGetError {
    Status500(models::ProblemDetailResponse),
    Status403(models::ProblemDetailResponse),
    Status415(std::collections::HashMap<String, serde_json::Value>),
    Status400(models::ProblemDetailResponse),
    Status401(models::ProblemDetailResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gw_api_v1_requests_request_id_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GwApiV1RequestsRequestIdStatusGetError {
    Status500(models::ProblemDetailResponse),
    Status403(models::ProblemDetailResponse),
    Status415(std::collections::HashMap<String, serde_json::Value>),
    Status400(models::ProblemDetailResponse),
    Status401(models::ProblemDetailResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`gw_api_v1_validations_usernames_username_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GwApiV1ValidationsUsernamesUsernameGetError {
    Status500(models::ProblemDetailResponse),
    Status403(models::ProblemDetailResponse),
    Status415(std::collections::HashMap<String, serde_json::Value>),
    Status400(models::ProblemDetailResponse),
    Status401(models::ProblemDetailResponse),
    UnknownValue(serde_json::Value),
}


/// Get list of brokers supported for given asset transfer type<br><br>**Scope**: `enumerations.read`<br>**Security Policy**: `HTTPS`
pub async fn gw_api_v1_enumerations_complex_asset_transfer_get(configuration: &configuration::Configuration, client_id: &str, instruction_type: &str) -> Result<models::GetBrokerListResponse, Error<GwApiV1EnumerationsComplexAssetTransferGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_client_id = client_id;
    let p_instruction_type = instruction_type;

    let uri_str = format!("{}/gw/api/v1/enumerations/complex-asset-transfer", configuration.base_path, client_id=crate::apis::urlencode(p_client_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("instructionType", &p_instruction_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetBrokerListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetBrokerListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GwApiV1EnumerationsComplexAssetTransferGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Used to query list of enumerations for attributes included within extPositionsTransfers, occupation, employerBusiness, financialInformation, affiliationDetails, tradingPermissions, etc.<br><br>**Scope**: `accounts.read` OR `enumerations.read`<br>**Security Policy**: `HTTPS`
pub async fn gw_api_v1_enumerations_enumeration_type_get(configuration: &configuration::Configuration, r#type: models::EnumerationType, currency: Option<&str>, ib_entity: Option<&str>, md_status_non_pro: Option<&str>, form_number: Option<&str>, language: Option<&str>) -> Result<models::EnumerationResponse, Error<GwApiV1EnumerationsEnumerationTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_currency = currency;
    let p_ib_entity = ib_entity;
    let p_md_status_non_pro = md_status_non_pro;
    let p_form_number = form_number;
    let p_language = language;

    let uri_str = format!("{}/gw/api/v1/enumerations/{enumerationType}", configuration.base_path, type=p_type.to_string());
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_currency {
        req_builder = req_builder.query(&[("currency", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ib_entity {
        req_builder = req_builder.query(&[("ibEntity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_md_status_non_pro {
        req_builder = req_builder.query(&[("mdStatusNonPro", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_form_number {
        req_builder = req_builder.query(&[("form-number", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EnumerationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EnumerationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GwApiV1EnumerationsEnumerationTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Apply predefined fee template to existing account.<br><br>**Scope**: `fee-templates.write`<br>**Security Policy**: `Signed JWT`
pub async fn gw_api_v1_fee_templates_post(configuration: &configuration::Configuration, client_id: &str, gw_api_v1_fee_templates_post_request: models::GwApiV1FeeTemplatesPostRequest) -> Result<models::AsynchronousInstructionResponse, Error<GwApiV1FeeTemplatesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_client_id = client_id;
    let p_gw_api_v1_fee_templates_post_request = gw_api_v1_fee_templates_post_request;

    let uri_str = format!("{}/gw/api/v1/fee-templates", configuration.base_path, client_id=crate::apis::urlencode(p_client_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_gw_api_v1_fee_templates_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AsynchronousInstructionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AsynchronousInstructionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GwApiV1FeeTemplatesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// View fee template applied to an existing account.<br><br>**Scope**: `fee-templates.read`<br>**Security Policy**: `Signed JWT`
pub async fn gw_api_v1_fee_templates_query_post(configuration: &configuration::Configuration, client_id: &str, gw_api_v1_fee_templates_query_post_request: models::GwApiV1FeeTemplatesQueryPostRequest) -> Result<models::QueryFeeTemplateResponse, Error<GwApiV1FeeTemplatesQueryPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_client_id = client_id;
    let p_gw_api_v1_fee_templates_query_post_request = gw_api_v1_fee_templates_query_post_request;

    let uri_str = format!("{}/gw/api/v1/fee-templates/query", configuration.base_path, client_id=crate::apis::urlencode(p_client_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_gw_api_v1_fee_templates_query_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::QueryFeeTemplateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::QueryFeeTemplateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GwApiV1FeeTemplatesQueryPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get forms<br><br>**Scope**: `accounts.read` OR `forms.read`<br>**Security Policy**: `HTTPS`
pub async fn gw_api_v1_forms_get(configuration: &configuration::Configuration, form_no: Option<Vec<i32>>, get_docs: Option<&str>, from_date: Option<&str>, to_date: Option<&str>, language: Option<&str>, projection: Option<&str>) -> Result<models::FormFileResponse, Error<GwApiV1FormsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_no = form_no;
    let p_get_docs = get_docs;
    let p_from_date = from_date;
    let p_to_date = to_date;
    let p_language = language;
    let p_projection = projection;

    let uri_str = format!("{}/gw/api/v1/forms", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_form_no {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("formNo".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("formNo", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_get_docs {
        req_builder = req_builder.query(&[("getDocs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_from_date {
        req_builder = req_builder.query(&[("fromDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_to_date {
        req_builder = req_builder.query(&[("toDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_projection {
        req_builder = req_builder.query(&[("projection", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FormFileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FormFileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GwApiV1FormsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of banks which support banking connection with Interactive Brokers.<br><br>**Scope**: `enumerations.read`<br>**Security Policy**: `HTTPS`
pub async fn gw_api_v1_participating_banks_get(configuration: &configuration::Configuration, client_id: &str, r#type: &str) -> Result<models::GetParticipatingListResponse, Error<GwApiV1ParticipatingBanksGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_client_id = client_id;
    let p_type = r#type;

    let uri_str = format!("{}/gw/api/v1/participating-banks", configuration.base_path, client_id=crate::apis::urlencode(p_client_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetParticipatingListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetParticipatingListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GwApiV1ParticipatingBanksGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch Requests' Details By Timeframe<br><br>**Scope**: `accounts.read`<br>**Security Policy**: `HTTPS`
pub async fn gw_api_v1_requests_get(configuration: &configuration::Configuration, request_details: models::RequestDetailsRequest) -> Result<models::RequestDetailsResponse, Error<GwApiV1RequestsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_details = request_details;

    let uri_str = format!("{}/gw/api/v1/requests", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("requestDetails", &p_request_details.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RequestDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RequestDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GwApiV1RequestsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns status for account management request<br><br>**Scope**: `accounts.read`<br>**Security Policy**: `HTTPS`
pub async fn gw_api_v1_requests_request_id_status_get(configuration: &configuration::Configuration, request_id: i32, r#type: &str) -> Result<models::GwApiV1RequestsRequestIdStatusGet200Response, Error<GwApiV1RequestsRequestIdStatusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_id = request_id;
    let p_type = r#type;

    let uri_str = format!("{}/gw/api/v1/requests/{requestId}/status", configuration.base_path, requestId=p_request_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GwApiV1RequestsRequestIdStatusGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GwApiV1RequestsRequestIdStatusGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GwApiV1RequestsRequestIdStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Verify whether user is valid and available<br><br>**Scope**: `accounts.read` OR `validations.read`<br>**Security Policy**: `HTTPS`
pub async fn gw_api_v1_validations_usernames_username_get(configuration: &configuration::Configuration, username: &str) -> Result<models::UserNameAvailableResponse, Error<GwApiV1ValidationsUsernamesUsernameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_username = username;

    let uri_str = format!("{}/gw/api/v1/validations/usernames/{username}", configuration.base_path, username=crate::apis::urlencode(p_username));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserNameAvailableResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserNameAvailableResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GwApiV1ValidationsUsernamesUsernameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}
