/*
 * IB REST API
 *
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.15.0
 * Contact: api@interactivebrokers.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`iserver_account_allocation_accounts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAllocationAccountsGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_allocation_group_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAllocationGroupDeletePostError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_allocation_group_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAllocationGroupGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_allocation_group_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAllocationGroupPostError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_allocation_group_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAllocationGroupPutError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_allocation_group_single_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAllocationGroupSinglePostError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_allocation_presets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAllocationPresetsGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_allocation_presets_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAllocationPresetsPostError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// Retrieves a list of all sub-accounts and returns their net liquidity and available equity for advisors to make decisions on what accounts should be allocated and how.
pub async fn iserver_account_allocation_accounts_get(
    configuration: &configuration::Configuration,
) -> Result<models::SubAccounts, Error<IserverAccountAllocationAccountsGetError>> {
    let uri_str = format!(
        "{}/iserver/account/allocation/accounts",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubAccounts`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubAccounts`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAllocationAccountsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn iserver_account_allocation_group_delete_post(
    configuration: &configuration::Configuration,
    iserver_account_allocation_group_delete_post_request: models::IserverAccountAllocationGroupDeletePostRequest,
) -> Result<
    models::IserverAccountAllocationGroupPut200Response,
    Error<IserverAccountAllocationGroupDeletePostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_iserver_account_allocation_group_delete_post_request =
        iserver_account_allocation_group_delete_post_request;

    let uri_str = format!(
        "{}/iserver/account/allocation/group/delete",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_iserver_account_allocation_group_delete_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IserverAccountAllocationGroupPut200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IserverAccountAllocationGroupPut200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAllocationGroupDeletePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves a list of all of the advisorâ€™s allocation groups. This describes the name of the allocation group, number of subaccounts within the group, and the method in use for the group.
pub async fn iserver_account_allocation_group_get(
    configuration: &configuration::Configuration,
) -> Result<models::AllocationGroups, Error<IserverAccountAllocationGroupGetError>> {
    let uri_str = format!(
        "{}/iserver/account/allocation/group",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AllocationGroups`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AllocationGroups`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAllocationGroupGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Add a new allocation group. This group can be used to trade in place of the {accountId} for the /iserver/account/{accountId}/orders endpoint.
pub async fn iserver_account_allocation_group_post(
    configuration: &configuration::Configuration,
    iserver_account_allocation_group_post_request: models::IserverAccountAllocationGroupPostRequest,
) -> Result<
    models::IserverAccountAllocationGroupPut200Response,
    Error<IserverAccountAllocationGroupPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_iserver_account_allocation_group_post_request =
        iserver_account_allocation_group_post_request;

    let uri_str = format!(
        "{}/iserver/account/allocation/group",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_iserver_account_allocation_group_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IserverAccountAllocationGroupPut200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IserverAccountAllocationGroupPut200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAllocationGroupPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Modify an existing allocation group.
pub async fn iserver_account_allocation_group_put(
    configuration: &configuration::Configuration,
    iserver_account_allocation_group_put_request: models::IserverAccountAllocationGroupPutRequest,
) -> Result<
    models::IserverAccountAllocationGroupPut200Response,
    Error<IserverAccountAllocationGroupPutError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_iserver_account_allocation_group_put_request =
        iserver_account_allocation_group_put_request;

    let uri_str = format!(
        "{}/iserver/account/allocation/group",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_iserver_account_allocation_group_put_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IserverAccountAllocationGroupPut200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IserverAccountAllocationGroupPut200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAllocationGroupPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves the configuration of a single account group. This describes the name of the allocation group, the specific accounts contained in the group, and the allocation method in use along with any relevant quantities.
pub async fn iserver_account_allocation_group_single_post(
    configuration: &configuration::Configuration,
    iserver_account_allocation_group_delete_post_request: models::IserverAccountAllocationGroupDeletePostRequest,
) -> Result<models::AllocationGroup, Error<IserverAccountAllocationGroupSinglePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_iserver_account_allocation_group_delete_post_request =
        iserver_account_allocation_group_delete_post_request;

    let uri_str = format!(
        "{}/iserver/account/allocation/group/single",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_iserver_account_allocation_group_delete_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AllocationGroup`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AllocationGroup`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAllocationGroupSinglePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve the preset behavior for allocation groups for specific events.
pub async fn iserver_account_allocation_presets_get(
    configuration: &configuration::Configuration,
) -> Result<models::Presets, Error<IserverAccountAllocationPresetsGetError>> {
    let uri_str = format!(
        "{}/iserver/account/allocation/presets",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Presets`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Presets`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAllocationPresetsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Set the preset behavior for new allocation groups for specific events.
pub async fn iserver_account_allocation_presets_post(
    configuration: &configuration::Configuration,
    presets: models::Presets,
) -> Result<
    models::IserverAccountAllocationPresetsPost200Response,
    Error<IserverAccountAllocationPresetsPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_presets = presets;

    let uri_str = format!(
        "{}/iserver/account/allocation/presets",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_presets);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IserverAccountAllocationPresetsPost200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IserverAccountAllocationPresetsPost200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAllocationPresetsPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
