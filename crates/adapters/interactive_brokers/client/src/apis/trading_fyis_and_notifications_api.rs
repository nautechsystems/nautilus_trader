/*
 * IB REST API
 *
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.15.0
 * Contact: api@interactivebrokers.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`fyi_deliveryoptions_device_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiDeliveryoptionsDeviceIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fyi_deliveryoptions_device_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiDeliveryoptionsDevicePostError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fyi_deliveryoptions_email_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiDeliveryoptionsEmailPutError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fyi_deliveryoptions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiDeliveryoptionsGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fyi_disclaimer_typecode_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiDisclaimerTypecodeGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fyi_disclaimer_typecode_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiDisclaimerTypecodePutError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fyi_notifications_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiNotificationsGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fyi_notifications_notification_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiNotificationsNotificationIdPutError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fyi_settings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiSettingsGetError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fyi_settings_typecode_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiSettingsTypecodePostError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fyi_unreadnumber_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FyiUnreadnumberGetError {
    Status401(String),
    Status423(models::FyiUnreadnumberGet423Response),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// Delete a specific device from our saved list of notification devices.
pub async fn fyi_deliveryoptions_device_id_delete(
    configuration: &configuration::Configuration,
    device_id: &str,
) -> Result<(), Error<FyiDeliveryoptionsDeviceIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_device_id = device_id;

    let uri_str = format!(
        "{}/fyi/deliveryoptions/{deviceId}",
        configuration.base_path,
        deviceId = p_device_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiDeliveryoptionsDeviceIdDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Choose whether a particular device is enabled or disabled.
pub async fn fyi_deliveryoptions_device_post(
    configuration: &configuration::Configuration,
    fyi_enable_device_option: models::FyiEnableDeviceOption,
) -> Result<models::FyiVt, Error<FyiDeliveryoptionsDevicePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_fyi_enable_device_option = fyi_enable_device_option;

    let uri_str = format!("{}/fyi/deliveryoptions/device", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_fyi_enable_device_option);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FyiVt`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FyiVt`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiDeliveryoptionsDevicePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Enable or disable your accountâ€™s primary email to receive notifications.
pub async fn fyi_deliveryoptions_email_put(
    configuration: &configuration::Configuration,
    enabled: serde_json::Value,
) -> Result<models::FyiVt, Error<FyiDeliveryoptionsEmailPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_enabled = enabled;

    let uri_str = format!("{}/fyi/deliveryoptions/email", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    req_builder = req_builder.query(&[("enabled", &p_enabled.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FyiVt`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FyiVt`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiDeliveryoptionsEmailPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Options for sending fyis to email and other devices.
pub async fn fyi_deliveryoptions_get(
    configuration: &configuration::Configuration,
) -> Result<models::DeliveryOptions, Error<FyiDeliveryoptionsGetError>> {
    let uri_str = format!("{}/fyi/deliveryoptions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeliveryOptions`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeliveryOptions`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiDeliveryoptionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Receive additional disclaimers based on the specified typecode.
pub async fn fyi_disclaimer_typecode_get(
    configuration: &configuration::Configuration,
    typecode: models::Typecodes,
) -> Result<models::DisclaimerInfo, Error<FyiDisclaimerTypecodeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_typecode = typecode;

    let uri_str = format!("{}/fyi/disclaimer/{}", configuration.base_path, p_typecode);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DisclaimerInfo`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DisclaimerInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiDisclaimerTypecodeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Mark a specific disclaimer message as read.
pub async fn fyi_disclaimer_typecode_put(
    configuration: &configuration::Configuration,
    typecode: models::Typecodes,
) -> Result<models::FyiVt, Error<FyiDisclaimerTypecodePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_typecode = typecode;

    let uri_str = format!("{}/fyi/disclaimer/{}", configuration.base_path, p_typecode);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FyiVt`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FyiVt`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiDisclaimerTypecodePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of available notifications.
pub async fn fyi_notifications_get(
    configuration: &configuration::Configuration,
    max: &str,
    include: Option<serde_json::Value>,
    exclude: Option<serde_json::Value>,
    id: Option<serde_json::Value>,
) -> Result<Vec<models::NotificationsInner>, Error<FyiNotificationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_max = max;
    let p_include = include;
    let p_exclude = exclude;
    let p_id = id;

    let uri_str = format!("{}/fyi/notifications", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("max", &p_max.to_string())]);
    if let Some(ref param_value) = p_include {
        req_builder = req_builder.query(&[("include", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::NotificationsInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::NotificationsInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiNotificationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Mark a particular notification message as read or unread.
pub async fn fyi_notifications_notification_id_put(
    configuration: &configuration::Configuration,
    notification_id: &str,
) -> Result<models::NotificationReadAcknowledge, Error<FyiNotificationsNotificationIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_notification_id = notification_id;

    let uri_str = format!(
        "{}/fyi/notifications/{}",
        configuration.base_path,
        crate::apis::urlencode(p_notification_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationReadAcknowledge`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationReadAcknowledge`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiNotificationsNotificationIdPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return the current choices of subscriptions for notifications.
pub async fn fyi_settings_get(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::FyiSettingsInner>, Error<FyiSettingsGetError>> {
    let uri_str = format!("{}/fyi/settings", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FyiSettingsInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FyiSettingsInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiSettingsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Enable or disable group of notifications by the specific typecode.
pub async fn fyi_settings_typecode_post(
    configuration: &configuration::Configuration,
    typecode: models::Typecodes,
    fyi_settings_typecode_post_request: models::FyiSettingsTypecodePostRequest,
) -> Result<models::FyiVt, Error<FyiSettingsTypecodePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_typecode = typecode;
    let p_fyi_settings_typecode_post_request = fyi_settings_typecode_post_request;

    let uri_str = format!(
        "{}/fyi/settings/{typecode}",
        configuration.base_path,
        typecode = p_typecode
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_fyi_settings_typecode_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FyiVt`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FyiVt`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiSettingsTypecodePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the total number of unread notifications
pub async fn fyi_unreadnumber_get(
    configuration: &configuration::Configuration,
) -> Result<models::FyiUnreadnumberGet200Response, Error<FyiUnreadnumberGetError>> {
    let uri_str = format!("{}/fyi/unreadnumber", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FyiUnreadnumberGet200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FyiUnreadnumberGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FyiUnreadnumberGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
