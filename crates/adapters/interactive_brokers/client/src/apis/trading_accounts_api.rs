/*
 * IB REST API
 *
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.15.0
 * Contact: api@interactivebrokers.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`acesws_account_id_signatures_and_owners_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AceswsAccountIdSignaturesAndOwnersGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_account_id_summary_available_funds_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdSummaryAvailableFundsGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_account_id_summary_balances_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdSummaryBalancesGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_account_id_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdSummaryGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_account_id_summary_margins_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdSummaryMarginsGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_account_id_summary_market_value_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdSummaryMarketValueGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_pnl_partitioned_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountPnlPartitionedGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountPostError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_search_search_pattern_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountSearchSearchPatternGetError {
    Status401(String),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_accounts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountsGetError {
    Status401(String),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_dynaccount_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverDynaccountPostError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// Receive a list of all applicant names on the account and for which account and entity is represented.
pub async fn acesws_account_id_signatures_and_owners_get(
    configuration: &configuration::Configuration,
    account_id: &str,
) -> Result<models::SignatureAndOwners, Error<AceswsAccountIdSignaturesAndOwnersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;

    let uri_str = format!(
        "{}/acesws/{}/signatures-and-owners",
        configuration.base_path,
        crate::apis::urlencode(p_account_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SignatureAndOwners`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SignatureAndOwners`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AceswsAccountIdSignaturesAndOwnersGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Provides a summary specific for avilable funds giving more depth than the standard /summary endpoint.
pub async fn iserver_account_account_id_summary_available_funds_get(
    configuration: &configuration::Configuration,
    account_id: &str,
) -> Result<
    models::AvailableFundsResponse,
    Error<IserverAccountAccountIdSummaryAvailableFundsGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;

    let uri_str = format!(
        "{}/iserver/account/{accountId}/summary/available_funds",
        configuration.base_path,
        accountId = crate::apis::urlencode(p_account_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AvailableFundsResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AvailableFundsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAccountIdSummaryAvailableFundsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn iserver_account_account_id_summary_balances_get(
    configuration: &configuration::Configuration,
    account_id: &str,
) -> Result<
    models::SummaryOfAccountBalancesResponse,
    Error<IserverAccountAccountIdSummaryBalancesGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;

    let uri_str = format!(
        "{}/iserver/account/{accountId}/summary/balances",
        configuration.base_path,
        accountId = crate::apis::urlencode(p_account_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SummaryOfAccountBalancesResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SummaryOfAccountBalancesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAccountIdSummaryBalancesGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Provides a general overview of the account details such as balance values.
pub async fn iserver_account_account_id_summary_get(
    configuration: &configuration::Configuration,
    account_id: &str,
) -> Result<models::AccountSummaryResponse, Error<IserverAccountAccountIdSummaryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;

    let uri_str = format!(
        "{}/iserver/account/{accountId}/summary",
        configuration.base_path,
        accountId = crate::apis::urlencode(p_account_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountSummaryResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountSummaryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAccountIdSummaryGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn iserver_account_account_id_summary_margins_get(
    configuration: &configuration::Configuration,
    account_id: &str,
) -> Result<
    models::SummaryOfAccountMarginResponse,
    Error<IserverAccountAccountIdSummaryMarginsGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;

    let uri_str = format!(
        "{}/iserver/account/{accountId}/summary/margins",
        configuration.base_path,
        accountId = crate::apis::urlencode(p_account_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SummaryOfAccountMarginResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SummaryOfAccountMarginResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAccountIdSummaryMarginsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn iserver_account_account_id_summary_market_value_get(
    configuration: &configuration::Configuration,
    account_id: &str,
) -> Result<
    models::SummaryMarketValueResponse,
    Error<IserverAccountAccountIdSummaryMarketValueGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;

    let uri_str = format!(
        "{}/iserver/account/{accountId}/summary/market_value",
        configuration.base_path,
        accountId = crate::apis::urlencode(p_account_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SummaryMarketValueResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SummaryMarketValueResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAccountIdSummaryMarketValueGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn iserver_account_pnl_partitioned_get(
    configuration: &configuration::Configuration,
) -> Result<models::PnlPartitionedResponse, Error<IserverAccountPnlPartitionedGetError>> {
    let uri_str = format!(
        "{}/iserver/account/pnl/partitioned",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PnlPartitionedResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PnlPartitionedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountPnlPartitionedGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Switch the active account for how you request data. Only available for financial advisors and multi-account structures.
pub async fn iserver_account_post(
    configuration: &configuration::Configuration,
    iserver_account_post_request: models::IserverAccountPostRequest,
) -> Result<models::SetAccountResponse, Error<IserverAccountPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_iserver_account_post_request = iserver_account_post_request;

    let uri_str = format!("{}/iserver/account", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_iserver_account_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SetAccountResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SetAccountResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of accounts matching a query pattern set in the request. Broker accounts configured with the DYNACCT property will not receive account information at login. Instead, they must dynamically query then set their account number. Customers without the DYNACCT property will receive a 503 error.
pub async fn iserver_account_search_search_pattern_get(
    configuration: &configuration::Configuration,
    search_pattern: &str,
) -> Result<models::DynAccountSearchResponse, Error<IserverAccountSearchSearchPatternGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_search_pattern = search_pattern;

    let uri_str = format!(
        "{}/iserver/account/search/{searchPattern}",
        configuration.base_path,
        searchPattern = crate::apis::urlencode(p_search_pattern)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DynAccountSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DynAccountSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountSearchSearchPatternGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
pub async fn iserver_accounts_get(
    configuration: &configuration::Configuration,
) -> Result<models::UserAccountsResponse, Error<IserverAccountsGetError>> {
    let uri_str = format!("{}/iserver/accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserAccountsResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserAccountsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Set the active dynamic account.
pub async fn iserver_dynaccount_post(
    configuration: &configuration::Configuration,
    iserver_dynaccount_post_request: models::IserverDynaccountPostRequest,
) -> Result<models::SetAccountResponse, Error<IserverDynaccountPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_iserver_dynaccount_post_request = iserver_dynaccount_post_request;

    let uri_str = format!("{}/iserver/dynaccount", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_iserver_dynaccount_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SetAccountResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SetAccountResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverDynaccountPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
