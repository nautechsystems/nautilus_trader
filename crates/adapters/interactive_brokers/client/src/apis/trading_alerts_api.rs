/*
 * IB REST API
 *
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.15.0
 * Contact: api@interactivebrokers.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`iserver_account_account_id_alert_activate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdAlertActivatePostError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_account_id_alert_alert_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdAlertAlertIdDeleteError {
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_account_id_alert_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdAlertPostError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorOnlyResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_account_id_alerts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAccountIdAlertsGetError {
    Status401(String),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_alert_alert_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountAlertAlertIdGetError {
    Status400(models::ErrorResponse),
    Status401(String),
    Status500(models::ErrorResponse),
    Status503(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`iserver_account_mta_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IserverAccountMtaGetError {
    UnknownValue(serde_json::Value),
}


/// Activate or Deactivate existing alerts created for this account. This does not delete alerts, but disables notifications until reactivated.
pub async fn iserver_account_account_id_alert_activate_post(configuration: &configuration::Configuration, account_id: &str, alert_activation_request: models::AlertActivationRequest) -> Result<models::AlertActivationResponse, Error<IserverAccountAccountIdAlertActivatePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_alert_activation_request = alert_activation_request;

    let uri_str = format!("{}/iserver/account/{accountId}/alert/activate", configuration.base_path, accountId=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_alert_activation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AlertActivationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AlertActivationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAccountIdAlertActivatePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Permanently delete an existing alert. Deleting an MTA alert will reset it to the default state.
pub async fn iserver_account_account_id_alert_alert_id_delete(configuration: &configuration::Configuration, account_id: &str, alert_id: &str, body: serde_json::Value) -> Result<models::AlertDeletionResponse, Error<IserverAccountAccountIdAlertAlertIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_alert_id = alert_id;
    let p_body = body;

    let uri_str = format!("{}/iserver/account/{accountId}/alert/{alertId}", configuration.base_path, accountId=crate::apis::urlencode(p_account_id), alertId=crate::apis::urlencode(p_alert_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AlertDeletionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AlertDeletionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAccountIdAlertAlertIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Endpoint used to create a new alert, or modify an existing alert.
pub async fn iserver_account_account_id_alert_post(configuration: &configuration::Configuration, account_id: &str, alert_creation_request: models::AlertCreationRequest) -> Result<models::AlertCreationResponse, Error<IserverAccountAccountIdAlertPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;
    let p_alert_creation_request = alert_creation_request;

    let uri_str = format!("{}/iserver/account/{accountId}/alert", configuration.base_path, accountId=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_alert_creation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AlertCreationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AlertCreationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAccountIdAlertPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a list of all alerts attached to the provided account.
pub async fn iserver_account_account_id_alerts_get(configuration: &configuration::Configuration, account_id: &str) -> Result<Vec<models::Alert>, Error<IserverAccountAccountIdAlertsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_account_id = account_id;

    let uri_str = format!("{}/iserver/account/{accountId}/alerts", configuration.base_path, accountId=crate::apis::urlencode(p_account_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Alert&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Alert&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAccountIdAlertsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Request details of a specific alert by providing the assigned alertId Id.
pub async fn iserver_account_alert_alert_id_get(configuration: &configuration::Configuration, alert_id: &str, r#type: &str) -> Result<models::AlertDetails, Error<IserverAccountAlertAlertIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_alert_id = alert_id;
    let p_type = r#type;

    let uri_str = format!("{}/iserver/account/alert/{alertId}", configuration.base_path, alertId=crate::apis::urlencode(p_alert_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("type", &p_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AlertDetails`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AlertDetails`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountAlertAlertIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve information about your MTA alert. Each login user only has one mobile trading assistant (MTA) alert with it’s own unique tool id that cannot be changed. MTA alerts can not be created or deleted, only modified. When modified a new order Id is generated.
pub async fn iserver_account_mta_get(configuration: &configuration::Configuration, ) -> Result<models::AlertDetails, Error<IserverAccountMtaGetError>> {

    let uri_str = format!("{}/iserver/account/mta", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AlertDetails`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AlertDetails`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IserverAccountMtaGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}
