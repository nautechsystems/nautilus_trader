/*
 * IB REST API
 *
 * The IB REST API reference documentation
 *
 * The version of the OpenAPI document: 2.15.0
 * Contact: api@interactivebrokers.com
 * Generated by: https://openapi-generator.tech
 */

use serde::{Deserialize, Serialize};

use crate::models;

/// ContractRules : detailed contract information
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct ContractRules {
    /// Indicates if the contract can trade algos or not.
    #[serde(rename = "algoEligible", skip_serializing_if = "Option::is_none")]
    pub algo_eligible: Option<bool>,
    /// Indicates if outsideRTH trading is permitted for the instrument
    #[serde(rename = "overnightEligible", skip_serializing_if = "Option::is_none")]
    pub overnight_eligible: Option<bool>,
    /// Indicates whether or not a cost report has been requested (Client Portal only).
    #[serde(rename = "costReport", skip_serializing_if = "Option::is_none")]
    pub cost_report: Option<bool>,
    /// Indicates permitted accountIDs that may trade the contract.
    #[serde(rename = "canTradeAcctIds", skip_serializing_if = "Option::is_none")]
    pub can_trade_acct_ids: Option<Vec<String>>,
    /// If rules information can not be received for any reason, it will be expressed here.
    #[serde(
        rename = "error",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub error: Option<Option<String>>,
    /// Indicates permitted order types for use with standard quantity trading.
    #[serde(rename = "orderTypes", skip_serializing_if = "Option::is_none")]
    pub order_types: Option<Vec<OrderTypes>>,
    /// Indicates permitted algo types for use with the given contract.
    #[serde(rename = "ibAlgoTypes", skip_serializing_if = "Option::is_none")]
    pub ib_algo_types: Option<Vec<IbAlgoTypes>>,
    /// Indicates permitted order types for use with fractional trading.
    #[serde(rename = "fraqTypes", skip_serializing_if = "Option::is_none")]
    pub fraq_types: Option<Vec<FraqTypes>>,
    /// Indicates if the order preview is forced upon the user before submission.
    #[serde(rename = "forceOrderPreview", skip_serializing_if = "Option::is_none")]
    pub force_order_preview: Option<bool>,
    /// Indicates accepted order types for use with cash quantity.
    #[serde(rename = "cqtTypes", skip_serializing_if = "Option::is_none")]
    pub cqt_types: Option<Vec<CqtTypes>>,
    #[serde(rename = "orderDefaults", skip_serializing_if = "Option::is_none")]
    pub order_defaults: Option<Box<models::ContractRulesOrderDefaults>>,
    /// Indicates permitted order types for use outside of regular trading hours.
    #[serde(rename = "orderTypesOutside", skip_serializing_if = "Option::is_none")]
    pub order_types_outside: Option<Vec<OrderTypesOutside>>,
    /// Default total quantity value for orders.
    #[serde(rename = "defaultSize", skip_serializing_if = "Option::is_none")]
    pub default_size: Option<i32>,
    /// Default cash value quantity.
    #[serde(rename = "cashSize", skip_serializing_if = "Option::is_none")]
    pub cash_size: Option<i32>,
    /// Indicates quantity increase for the contract.
    #[serde(rename = "sizeIncrement", skip_serializing_if = "Option::is_none")]
    pub size_increment: Option<i32>,
    /// Indicates allowed tif types supported for the contract.
    #[serde(rename = "tifTypes", skip_serializing_if = "Option::is_none")]
    pub tif_types: Option<Vec<String>>,
    #[serde(rename = "tifDefaults", skip_serializing_if = "Option::is_none")]
    pub tif_defaults: Option<Box<models::ContractRulesTifDefaults>>,
    /// Default limit price for the given contract.
    #[serde(rename = "limitPrice", skip_serializing_if = "Option::is_none")]
    pub limit_price: Option<i32>,
    /// Default stop price for the given contract.
    #[serde(rename = "stopPrice", skip_serializing_if = "Option::is_none")]
    pub stop_price: Option<i32>,
    /// Order origin designation for US securities options and Options Clearing Corporation
    #[serde(
        rename = "orderOrigination",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub order_origination: Option<Option<String>>,
    /// Indicates if the order preview is required (for client portal only)
    #[serde(rename = "preview", skip_serializing_if = "Option::is_none")]
    pub preview: Option<bool>,
    /// Standard display increment rule for the instrument.
    #[serde(
        rename = "displaySize",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub display_size: Option<Option<i32>>,
    /// Indicates decimal places for fractional order size.
    #[serde(rename = "fraqInt", skip_serializing_if = "Option::is_none")]
    pub fraq_int: Option<i32>,
    /// Indicates base currency for the instrument.
    #[serde(rename = "cashCcy", skip_serializing_if = "Option::is_none")]
    pub cash_ccy: Option<String>,
    /// Indicates cash quantity increment rules.
    #[serde(rename = "cashQtyIncr", skip_serializing_if = "Option::is_none")]
    pub cash_qty_incr: Option<i32>,
    /// Signifies the magnifier of a given contract. This is separate from the price multiplier, and will typically return ‘null’
    #[serde(
        rename = "priceMagnifier",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub price_magnifier: Option<Option<i32>>,
    /// Indicates if the value of the contract can be negative (true) or if it is always positive (false).
    #[serde(rename = "negativeCapable", skip_serializing_if = "Option::is_none")]
    pub negative_capable: Option<bool>,
    /// Indicates the type of increment style.
    #[serde(rename = "incrementType", skip_serializing_if = "Option::is_none")]
    pub increment_type: Option<i32>,
    /// Indicates increment rule values including lowerEdge and increment value.
    #[serde(rename = "incrementRules", skip_serializing_if = "Option::is_none")]
    pub increment_rules: Option<Vec<models::ContractRulesIncrementRulesInner>>,
    #[serde(rename = "hasSecondary", skip_serializing_if = "Option::is_none")]
    pub has_secondary: Option<bool>,
    /// Lists the available order types supported when modifying the order.
    #[serde(rename = "modTypes", skip_serializing_if = "Option::is_none")]
    pub mod_types: Option<Vec<String>>,
    /// Minimum increment values for prices
    #[serde(rename = "increment", skip_serializing_if = "Option::is_none")]
    pub increment: Option<i32>,
    /// Number of decimal places to indicate the increment value.
    #[serde(rename = "incrementDigits", skip_serializing_if = "Option::is_none")]
    pub increment_digits: Option<i32>,
}

impl ContractRules {
    /// detailed contract information
    pub fn new() -> ContractRules {
        ContractRules {
            algo_eligible: None,
            overnight_eligible: None,
            cost_report: None,
            can_trade_acct_ids: None,
            error: None,
            order_types: None,
            ib_algo_types: None,
            fraq_types: None,
            force_order_preview: None,
            cqt_types: None,
            order_defaults: None,
            order_types_outside: None,
            default_size: None,
            cash_size: None,
            size_increment: None,
            tif_types: None,
            tif_defaults: None,
            limit_price: None,
            stop_price: None,
            order_origination: None,
            preview: None,
            display_size: None,
            fraq_int: None,
            cash_ccy: None,
            cash_qty_incr: None,
            price_magnifier: None,
            negative_capable: None,
            increment_type: None,
            increment_rules: None,
            has_secondary: None,
            mod_types: None,
            increment: None,
            increment_digits: None,
        }
    }
}
/// Indicates permitted order types for use with standard quantity trading.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum OrderTypes {
    #[serde(rename = "limit")]
    Limit,
    #[serde(rename = "midprice")]
    Midprice,
    #[serde(rename = "market")]
    Market,
    #[serde(rename = "stop")]
    Stop,
    #[serde(rename = "stop_limit")]
    StopLimit,
    #[serde(rename = "mit")]
    Mit,
    #[serde(rename = "lit")]
    Lit,
    #[serde(rename = "trailing_stop")]
    TrailingStop,
    #[serde(rename = "trailing_stop_limit")]
    TrailingStopLimit,
    #[serde(rename = "relative")]
    Relative,
    #[serde(rename = "marketonclose")]
    Marketonclose,
    #[serde(rename = "limitonclose")]
    Limitonclose,
}

impl Default for OrderTypes {
    fn default() -> OrderTypes {
        Self::Limit
    }
}
/// Indicates permitted algo types for use with the given contract.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum IbAlgoTypes {
    #[serde(rename = "limit")]
    Limit,
    #[serde(rename = "stop_limit")]
    StopLimit,
    #[serde(rename = "lit")]
    Lit,
    #[serde(rename = "trailing_stop_limit")]
    TrailingStopLimit,
    #[serde(rename = "relative")]
    Relative,
    #[serde(rename = "marketonclose")]
    Marketonclose,
    #[serde(rename = "limitonclose")]
    Limitonclose,
}

impl Default for IbAlgoTypes {
    fn default() -> IbAlgoTypes {
        Self::Limit
    }
}
/// Indicates permitted order types for use with fractional trading.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum FraqTypes {
    #[serde(rename = "limit")]
    Limit,
    #[serde(rename = "market")]
    Market,
    #[serde(rename = "stop")]
    Stop,
    #[serde(rename = "stop_limit")]
    StopLimit,
    #[serde(rename = "mit")]
    Mit,
    #[serde(rename = "lit")]
    Lit,
    #[serde(rename = "trailing_stop")]
    TrailingStop,
    #[serde(rename = "trailing_stop_limit")]
    TrailingStopLimit,
}

impl Default for FraqTypes {
    fn default() -> FraqTypes {
        Self::Limit
    }
}
/// Indicates accepted order types for use with cash quantity.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum CqtTypes {
    #[serde(rename = "limit")]
    Limit,
    #[serde(rename = "market")]
    Market,
    #[serde(rename = "stop")]
    Stop,
    #[serde(rename = "stop_limit")]
    StopLimit,
    #[serde(rename = "mit")]
    Mit,
    #[serde(rename = "lit")]
    Lit,
    #[serde(rename = "trailing_stop")]
    TrailingStop,
    #[serde(rename = "trailing_stop_limit")]
    TrailingStopLimit,
}

impl Default for CqtTypes {
    fn default() -> CqtTypes {
        Self::Limit
    }
}
/// Indicates permitted order types for use outside of regular trading hours.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum OrderTypesOutside {
    #[serde(rename = "limit")]
    Limit,
    #[serde(rename = "stop_limit")]
    StopLimit,
    #[serde(rename = "lit")]
    Lit,
    #[serde(rename = "trailing_stop_limit")]
    TrailingStopLimit,
    #[serde(rename = "relative")]
    Relative,
}

impl Default for OrderTypesOutside {
    fn default() -> OrderTypesOutside {
        Self::Limit
    }
}
