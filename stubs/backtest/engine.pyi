from collections.abc import Callable
from collections.abc import Iterator
from datetime import datetime
from decimal import Decimal
from typing import Any

import pandas as pd

from nautilus_trader.backtest.results import BacktestResult
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.core import nautilus_pyo3
from nautilus_trader.core.uuid import UUID4
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import BookType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.system.kernel import NautilusKernel
from nautilus_trader.trading.trader import Trader
from stubs.backtest.exchange import SimulatedExchange
from stubs.backtest.models import FeeModel
from stubs.backtest.models import FillModel
from stubs.backtest.models import LatencyModel
from stubs.backtest.modules import SimulationModule
from stubs.cache.base import CacheFacade
from stubs.common.actor import Actor
from stubs.common.component import Logger
from stubs.common.component import LogGuard
from stubs.core.data import Data
from stubs.data.engine import DataEngine
from stubs.data.messages import DataCommand
from stubs.data.messages import DataResponse
from stubs.data.messages import RequestData
from stubs.data.messages import SubscribeData
from stubs.data.messages import UnsubscribeData
from stubs.execution.algorithm import ExecAlgorithm
from stubs.model.identifiers import ClientId
from stubs.model.identifiers import InstrumentId
from stubs.model.identifiers import TraderId
from stubs.model.identifiers import Venue
from stubs.model.instruments.base import Instrument
from stubs.model.objects import Currency
from stubs.model.objects import Money
from stubs.portfolio.base import PortfolioFacade
from stubs.trading.strategy import Strategy

class BacktestEngine:

    _config: BacktestEngineConfig
    _accumulator: Any
    _run_config_id: str | None
    _run_id: UUID4 | None
    _venues: dict[Venue, SimulatedExchange]
    _has_data: set[InstrumentId]
    _has_book_data: set[InstrumentId]
    _data: list[Data]
    _data_len: int
    _iteration: int
    _last_ns: int
    _end_ns: int
    _run_started: pd.Timestamp | None
    _run_finished: pd.Timestamp | None
    _backtest_start: pd.Timestamp | None
    _backtest_end: pd.Timestamp | None
    _kernel: NautilusKernel
    _instance_id: UUID4
    _log: Logger
    _data_engine: DataEngine
    _data_requests: dict[str, RequestData]
    _backtest_subscription_names: set[Any]
    _data_iterator: Any

    def __init__(self, config: BacktestEngineConfig | None = None) -> None: ...
    def __del__(self) -> None: ...
    @property
    def trader_id(self) -> TraderId: ...
    @property
    def machine_id(self) -> str: ...
    @property
    def instance_id(self) -> UUID4: ...
    @property
    def kernel(self) -> NautilusKernel: ...
    @property
    def logger(self) -> Logger: ...
    @property
    def run_config_id(self) -> str | None: ...
    @property
    def run_id(self) -> UUID4 | None: ...
    @property
    def iteration(self) -> int: ...
    @property
    def run_started(self) -> pd.Timestamp | None: ...
    @property
    def run_finished(self) -> pd.Timestamp | None: ...
    @property
    def backtest_start(self) -> pd.Timestamp | None: ...
    @property
    def backtest_end(self) -> pd.Timestamp | None: ...
    @property
    def trader(self) -> Trader: ...
    @property
    def cache(self) -> CacheFacade: ...
    @property
    def data(self) -> list[Data]: ...
    @property
    def portfolio(self) -> PortfolioFacade: ...
    def get_log_guard(self) -> nautilus_pyo3.LogGuard | LogGuard | None: ...
    def list_venues(self) -> list[Venue]: ...
    def add_venue(
        self,
        venue: Venue,
        oms_type: OmsType,
        account_type: AccountType,
        starting_balances: list[Money],
        base_currency: Currency | None = None,
        default_leverage: Decimal | None = None,
        leverages: dict[InstrumentId, Decimal] | None = None,
        modules: list[SimulationModule] | None = None,
        fill_model: FillModel | None = None,
        fee_model: FeeModel | None = None,
        latency_model: LatencyModel | None = None,
        book_type: BookType = ...,
        routing: bool = False,
        frozen_account: bool = False,
        reject_stop_orders: bool = True,
        support_gtd_orders: bool = True,
        support_contingent_orders: bool = True,
        use_position_ids: bool = True,
        use_random_ids: bool = False,
        use_reduce_only: bool = True,
        use_message_queue: bool = True,
        bar_execution: bool = True,
        bar_adaptive_high_low_ordering: bool = False,
        trade_execution: bool = False,
    ) -> None: ...
    def change_fill_model(self, venue: Venue, model: FillModel) -> None: ...
    def add_instrument(self, instrument: Instrument) -> None: ...
    def add_data(
        self,
        data: list[Data],
        client_id: ClientId | None = None,
        validate: bool = True,
        sort: bool = True,
    ) -> None: ...
    def _handle_data_command(self, command: DataCommand) -> None: ...
    def _handle_subscribe(self, command: SubscribeData) -> None: ...
    def _handle_data_response(self, response: DataResponse) -> None: ...
    def _handle_unsubscribe(self, command: UnsubscribeData) -> None: ...
    def _handle_empty_data(self, subscription_name: str, last_ts_init: int) -> None: ...
    def dump_pickled_data(self) -> bytes: ...
    def load_pickled_data(self, data: bytes) -> None: ...
    def add_actor(self, actor: Actor) -> None: # Actor
        ...
    def add_actors(self, actors: list[Actor]) -> None: # Actor
        ...
    def add_strategy(self, strategy: Strategy) -> None: ...
    def add_strategies(self, strategies: list[Strategy]) -> None: ...
    def add_exec_algorithm(self, exec_algorithm: ExecAlgorithm) -> None: ...
    def add_exec_algorithms(self, exec_algorithms: list[ExecAlgorithm]) -> None: ...
    def reset(self) -> None: ...
    def clear_data(self) -> None: ...
    def clear_actors(self) -> None: ...
    def clear_strategies(self) -> None: ...
    def clear_exec_algorithms(self) -> None: ...
    def dispose(self) -> None: ...
    def run(
        self,
        start: datetime | str | int | None = None,
        end: datetime | str | int | None = None,
        run_config_id: str | None = None,
        streaming: bool = False,
    ) -> None: ...
    def _run(
        self,
        start: datetime | str | int | None = None,
        end: datetime | str | int | None = None,
        run_config_id: str | None = None,
        streaming: bool = False,
    ) -> None: ...
    def end(self) -> None: ...
    def get_result(self) -> BacktestResult: ...
    def _get_log_color_code(self) -> str: ...
    def _log_pre_run(self) -> None: ...
    def _log_run(self, start: pd.Timestamp, end: pd.Timestamp) -> None: ...
    def _log_post_run(self) -> None: ...
    def _add_data_client_if_not_exists(self, client_id: ClientId) -> None: ...
    def _add_market_data_client_if_not_exists(self, venue: Venue) -> None: ...
    def set_default_market_data_client(self) -> None: ...

class BacktestDataIterator:
    _empty_data_callback: Callable[[str, int], None] | None
    _log: Logger
    _data: dict[int, list[Data]]
    _data_name: dict[int, str]
    _data_priority: dict[str, int]
    _data_len: dict[int, int]
    _data_index: dict[int, int]
    _heap: list[tuple[int, int, int]]
    _next_data_priority: int

    def __init__(self, empty_data_callback: Callable[[str, int], None] | None = None) -> None: ...
    def _reset_single_data(self) -> None: ...
    def add_data(self, data_name: str, data_list: list[Data], append_data: bool = True) -> None: ...
    def remove_data(self, data_name: str) -> None: ...
    def _activate_single_data(self) -> None: ...
    def _deactivate_single_data(self) -> None: ...
    def next(self) -> Data | None: ...
    def _push_data(self, data_priority: int, data_index: int) -> None: ...
    def reset(self) -> None: ...
    def _reset_heap(self) -> None: ...
    def set_index(self, data_name: str, index: int) -> None: ...
    def is_done(self) -> bool: ...
    def all_data(self) -> dict[str, list[Data]]: ...
    def data(self, data_name: str) -> list[Data]: ...
    def __iter__(self) -> Iterator[Data]: ...
    def __next__(self) -> Data: ...

