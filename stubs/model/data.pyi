from datetime import timedelta
from enum import Enum
from typing import Any

import numpy as np

from nautilus_trader.core import nautilus_pyo3
from nautilus_trader.model.enums import AggregationSource
from nautilus_trader.model.enums import AggressorSide
from nautilus_trader.model.enums import BookAction
from nautilus_trader.model.enums import InstrumentCloseType
from nautilus_trader.model.enums import MarketStatusAction
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import PriceType
from stubs.core.data import Data
from stubs.model.identifiers import InstrumentId
from stubs.model.identifiers import TradeId
from stubs.model.objects import Price
from stubs.model.objects import Quantity

class BarAggregation(Enum): # skip-validate
    TICK = 1
    TICK_IMBALANCE = 2
    TICK_RUNS = 3
    VOLUME = 4
    VOLUME_IMBALANCE = 5
    VOLUME_RUNS = 6
    VALUE = 7
    VALUE_IMBALANCE = 8
    VALUE_RUNS = 9
    MILLISECOND = 10
    SECOND = 11
    MINUTE = 12
    HOUR = 13
    DAY = 14
    WEEK = 15
    MONTH = 16


def capsule_to_list(capsule) -> list[Data]: ...
def capsule_to_data(capsule) -> Data: ...


class BarSpecification:

    def __init__(self, step: int, aggregation: BarAggregation, price_type: PriceType) -> None: ...
    def __getstate__(self) -> tuple[int, BarAggregation, PriceType]: ...
    def __setstate__(self, state: tuple[int, BarAggregation, PriceType]) -> None: ...
    def __eq__(self, other: BarSpecification) -> bool: ...
    def __lt__(self, other: BarSpecification) -> bool: ...
    def __le__(self, other: BarSpecification) -> bool: ...
    def __gt__(self, other: BarSpecification) -> bool: ...
    def __ge__(self, other: BarSpecification) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def step(self) -> int: ...
    @property
    def aggregation(self) -> BarAggregation: ...
    @property
    def price_type(self) -> PriceType: ...
    @property
    def timedelta(self) -> timedelta: ...
    @staticmethod
    def from_str(value: str) -> BarSpecification: ...
    @staticmethod
    def from_timedelta(duration: timedelta, price_type: PriceType) -> BarSpecification: ...
    @staticmethod
    def check_time_aggregated(aggregation: BarAggregation) -> bool: ...
    @staticmethod
    def check_threshold_aggregated(aggregation: BarAggregation) -> bool: ...
    @staticmethod
    def check_information_aggregated(aggregation: BarAggregation) -> bool: ...
    def is_time_aggregated(self) -> bool: ...
    def is_threshold_aggregated(self) -> bool: ...
    def is_information_aggregated(self) -> bool: ...

class BarType:

    def __init__(self, instrument_id: InstrumentId, bar_spec: BarSpecification, aggregation_source: AggregationSource = AggregationSource.EXTERNAL) -> None: ...
    def __getstate__(self) -> tuple[Any, ...]: ...
    def __setstate__(self, state: tuple[Any, ...]) -> None: ...
    def __eq__(self, other: BarType) -> bool: ...
    def __lt__(self, other: BarType) -> bool: ...
    def __le__(self, other: BarType) -> bool: ...
    def __gt__(self, other: BarType) -> bool: ...
    def __ge__(self, other: BarType) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def instrument_id(self) -> InstrumentId: ...
    @property
    def spec(self) -> BarSpecification: ...
    @property
    def aggregation_source(self) -> AggregationSource: ...
    @staticmethod
    def from_str(value: str) -> BarType: ...
    def is_externally_aggregated(self) -> bool: ...
    def is_internally_aggregated(self) -> bool: ...
    @staticmethod
    def new_composite(instrument_id: InstrumentId, bar_spec: BarSpecification, aggregation_source: AggregationSource, composite_step: int, composite_aggregation: BarAggregation, composite_aggregation_source: AggregationSource) -> BarType: ...
    def is_standard(self) -> bool: ...
    def is_composite(self) -> bool: ...
    def standard(self) -> BarType: ...
    def composite(self) -> BarType: ...

class Bar(Data):

    is_revision: bool
    def __init__(self, bar_type: BarType, open: Price, high: Price, low: Price, close: Price, volume: Quantity, ts_event: int, ts_init: int, is_revision: bool = False) -> None: ...
    def __getstate__(self) -> tuple[Any, ...]: ...
    def __setstate__(self, state: tuple[Any, ...]) -> None: ...
    def __eq__(self, other: Bar) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def bar_type(self) -> BarType: ...
    @property
    def open(self) -> Price: ...
    @property
    def high(self) -> Price: ...
    @property
    def low(self) -> Price: ...
    @property
    def close(self) -> Price: ...
    @property
    def volume(self) -> Quantity: ...
    @property
    def ts_event(self) -> int: ...
    @property
    def ts_init(self) -> int: ...
    @staticmethod
    def from_raw_arrays_to_list(
        bar_type: BarType, 
        price_prec: int, 
        size_prec: int, 
        opens: np.ndarray, # skip-validate
        highs: np.ndarray, # skip-validate
        lows: np.ndarray, # skip-validate
        closes: np.ndarray, # skip-validate
        volumes: np.ndarray, # skip-validate
        ts_events: np.ndarray, # skip-validate
        ts_inits: np.ndarray # skip-validate
    ) -> list[Bar]: ...
    @staticmethod
    def from_raw(bar_type: BarType, open: PriceRaw, high: PriceRaw, low: PriceRaw, close: PriceRaw, price_prec: int, volume: QuantityRaw, size_prec: int, ts_event: int, ts_init: int) -> Bar: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> Bar: ...
    @staticmethod
    def to_dict(obj: Bar) -> dict[str, Any]: ...
    @staticmethod
    def to_pyo3_list(bars: list[Bar]) -> list[nautilus_pyo3.Bar]: ...
    @staticmethod
    def from_pyo3_list(pyo3_bars: list[nautilus_pyo3.Bar]) -> list[Bar]: ...
    @staticmethod
    def from_pyo3(pyo3_bar: nautilus_pyo3.Bar) -> Bar: ...
    def to_pyo3(self) -> nautilus_pyo3.Bar: ...
    def is_single_price(self) -> bool: ...

class DataType:

    type: type
    metadata: dict
    topic: str
    def __init__(self, type: type, metadata: dict[Any, Any] | None = None) -> None: ...
    def __eq__(self, other: DataType) -> bool: ...
    def __lt__(self, other: DataType) -> bool: ...
    def __le__(self, other: DataType) -> bool: ...
    def __gt__(self, other: DataType) -> bool: ...
    def __ge__(self, other: DataType) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class CustomData(Data):

    data_type: DataType
    data: Data
    def __init__(self, data_type: DataType, data: Data) -> None: ...
    def __repr__(self) -> str: ...
    @property
    def ts_event(self) -> int: ...
    @property
    def ts_init(self) -> int: ...

NULL_ORDER: BookOrder

class BookOrder:

    def __init__(self, side: OrderSide, price: Price, size: Quantity, order_id: int) -> None: ...
    def __getstate__(self) -> tuple[OrderSide, int, int, int, int, int]: ...
    def __setstate__(self, state: tuple[OrderSide, int, int, int, int, int]) -> None: ...
    def __eq__(self, other: BookOrder) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    @property
    def price(self) -> Price: ...
    @property
    def size(self) -> Quantity: ...
    @property
    def side(self) -> OrderSide: ...
    @property
    def order_id(self) -> int: ...
    def exposure(self) -> float: ...
    def signed_size(self) -> float: ...
    @staticmethod
    def from_raw(side: OrderSide, price_raw: PriceRaw, price_prec: int, size_raw: QuantityRaw, size_prec: int, order_id: int) -> BookOrder: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> BookOrder: ...
    @staticmethod
    def to_dict(obj: BookOrder) -> dict[str, Any]: ...

class OrderBookDelta(Data):

    def __init__(self, instrument_id: InstrumentId, action: BookAction, order: BookOrder | None, flags: int, sequence: int, ts_event: int, ts_init: int) -> None: ...
    def __getstate__(self) -> tuple[Any, ...]: ...
    def __setstate__(self, state: tuple[Any, ...]) -> None: ...
    def __eq__(self, other: OrderBookDelta) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    @property
    def instrument_id(self) -> InstrumentId: ...
    @property
    def action(self) -> BookAction: ...
    @property
    def is_add(self) -> BookAction: ...
    @property
    def is_update(self) -> BookAction: ...
    @property
    def is_delete(self) -> BookAction: ...
    @property
    def is_clear(self) -> BookAction: ...
    @property
    def order(self) -> BookOrder | None: ...
    @property
    def flags(self) -> int: ...
    @property
    def sequence(self) -> int: ...
    @property
    def ts_event(self) -> int: ...
    @property
    def ts_init(self) -> int: ...
    @staticmethod
    def list_from_capsule(capsule: Any) -> list[OrderBookDelta]: ...
    @staticmethod
    def capsule_from_list(items: list[OrderBookDelta]) -> Any: ...
    @staticmethod
    def from_raw(instrument_id: InstrumentId, action: BookAction, side: OrderSide, price_raw: PriceRaw, price_prec: int, size_raw: QuantityRaw, size_prec: int, order_id: int, flags: int, sequence: int, ts_event: int, ts_init: int) -> OrderBookDelta: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> OrderBookDelta: ...
    @staticmethod
    def to_dict(obj: OrderBookDelta) -> dict[str, Any]: ...
    @staticmethod
    def clear(instrument_id: InstrumentId, sequence: int, ts_event: int, ts_init: int) -> OrderBookDelta: ...
    @staticmethod
    def to_pyo3_list(deltas: list[OrderBookDelta]) -> list[nautilus_pyo3.OrderBookDelta]: ...
    @staticmethod
    def from_pyo3(pyo3_delta: nautilus_pyo3.OrderBookDelta) -> OrderBookDelta: ...
    @staticmethod
    def from_pyo3_list(pyo3_deltas: list[nautilus_pyo3.OrderBookDelta]) -> list[OrderBookDelta]: ...

class OrderBookDeltas(Data):

    def __init__(self, instrument_id: InstrumentId, deltas: list[OrderBookDelta]) -> None: ...
    def __getstate__(self) -> tuple[str, bytes]: ...
    def __setstate__(self, state: tuple[str, bytes]) -> None: ...
    def __del__(self) -> None: ...
    def __eq__(self, other: OrderBookDeltas) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    @property
    def instrument_id(self) -> InstrumentId: ...
    @property
    def deltas(self) -> list[OrderBookDelta]: ...
    @property
    def is_snapshot(self) -> bool: ...
    @property
    def flags(self) -> int: ...
    @property
    def sequence(self) -> int: ...
    @property
    def ts_event(self) -> int: ...
    @property
    def ts_init(self) -> int: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> OrderBookDeltas: ...
    @staticmethod
    def to_dict(obj: OrderBookDeltas) -> dict[str, Any]: ...
    @staticmethod
    def batch(data: list[OrderBookDelta]) -> list[OrderBookDeltas]: ...
    def to_capsule(self) -> Any: ...
    def to_pyo3(self) -> nautilus_pyo3.OrderBookDeltas: ...

class OrderBookDepth10(Data):

    def __init__(self, instrument_id: InstrumentId, bids: list[BookOrder], asks: list[BookOrder], bid_counts: list[int], ask_counts: list[int], flags: int, sequence: int, ts_event: int, ts_init: int) -> None: ...
    def __getstate__(self) -> tuple[str, bytes, bytes, bytes, bytes, int, int, int, int]: ...
    def __setstate__(self, state: tuple[str, bytes, bytes, bytes, bytes, int, int, int, int]) -> None: ...
    def __eq__(self, other: OrderBookDepth10) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    @property
    def instrument_id(self) -> InstrumentId: ...
    @property
    def bids(self) -> list[BookOrder]: ...
    @property
    def asks(self) -> list[BookOrder]: ...
    @property
    def bid_counts(self) -> list[int]: ...
    @property
    def ask_counts(self) -> list[int]: ...
    @property
    def flags(self) -> int: ...
    @property
    def sequence(self) -> int: ...
    @property
    def ts_event(self) -> int: ...
    @property
    def ts_init(self) -> int: ...
    @staticmethod
    def list_from_capsule(capsule: Any) -> list[OrderBookDepth10]: ...
    @staticmethod
    def capsule_from_list(items: list[OrderBookDepth10]) -> Any: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> OrderBookDepth10: ...
    @staticmethod
    def to_dict(obj: OrderBookDepth10) -> dict[str, Any]: ...
    @staticmethod
    def from_pyo3(pyo3_depth: nautilus_pyo3.OrderBookDepth10) -> OrderBookDepth10: ...
    @staticmethod
    def from_pyo3_list(pyo3_depths: list[nautilus_pyo3.OrderBookDepth10]) -> list[OrderBookDepth10]: ...

class InstrumentStatus(Data):

    instrument_id: InstrumentId
    action: MarketStatusAction
    ts_event: int
    ts_init: int
    reason: str | None
    trading_event: str | None
    _is_trading: bool | None
    _is_quoting: bool | None
    _is_short_sell_restricted: bool | None
    def __init__(self, instrument_id: InstrumentId, action: MarketStatusAction, ts_event: int, ts_init: int, reason: str | None = None, trading_event: str | None = None, is_trading: bool | None = None, is_quoting: bool | None = None, is_short_sell_restricted: bool | None = None) -> None: ...
    def __eq__(self, other: InstrumentStatus) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    @property
    def is_trading(self) -> bool | None: ...
    @property
    def is_quoting(self) -> bool | None: ...
    @property
    def is_short_sell_restricted(self) -> bool | None: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> InstrumentStatus: ...
    @staticmethod
    def to_dict(obj: InstrumentStatus) -> dict[str, Any]: ...
    @staticmethod
    def from_pyo3_list(pyo3_status_list: list[nautilus_pyo3.InstrumentStatus]) -> list[InstrumentStatus]: ...
    @staticmethod
    def from_pyo3(pyo3_status: nautilus_pyo3.InstrumentStatus) -> InstrumentStatus: ...
    def to_pyo3(self) -> nautilus_pyo3.InstrumentStatus: ...

class InstrumentClose(Data):

    instrument_id: InstrumentId
    close_price: Price
    close_type: InstrumentCloseType
    ts_event: int
    ts_init: int
    def __init__(self, instrument_id: InstrumentId, close_price: Price, close_type: InstrumentCloseType, ts_event: int, ts_init: int) -> None: ...
    def __eq__(self, other: InstrumentClose) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> InstrumentClose: ...
    @staticmethod
    def to_dict(obj: InstrumentClose) -> dict[str, Any]: ...
    @staticmethod
    def to_pyo3_list(closes: list[InstrumentClose]) -> list[nautilus_pyo3.InstrumentClose]: ...
    @staticmethod
    def from_pyo3_list(pyo3_closes: list[nautilus_pyo3.InstrumentClose]) -> list[InstrumentClose]: ...
    @staticmethod
    def from_pyo3(pyo3_close: nautilus_pyo3.InstrumentClose) -> InstrumentClose: ...
    def to_pyo3(self) -> nautilus_pyo3.IndexPriceUpdate: ...

class QuoteTick(Data):

    def __init__(self, instrument_id: InstrumentId, bid_price: Price, ask_price: Price, bid_size: Quantity, ask_size: Quantity, ts_event: int, ts_init: int) -> None: ...
    def __getstate__(self) -> tuple[str, int, int, int, int, int, int, int, int, int, int]: ...
    def __setstate__(self, state: tuple[str, int, int, int, int, int, int, int, int, int, int]) -> None: ...
    def __eq__(self, other: QuoteTick) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def instrument_id(self) -> InstrumentId: ...
    @property
    def bid_price(self) -> Price: ...
    @property
    def ask_price(self) -> Price: ...
    @property
    def bid_size(self) -> Quantity: ...
    @property
    def ask_size(self) -> Quantity: ...
    @property
    def ts_event(self) -> int: ...
    @property
    def ts_init(self) -> int: ...
    @staticmethod
    def from_raw_arrays_to_list(instrument_id: InstrumentId, price_prec: int, size_prec: int, bid_prices_raw: np.ndarray[Any, np.dtype[np.float64]], ask_prices_raw: np.ndarray[Any, np.dtype[np.float64]], bid_sizes_raw: np.ndarray[Any, np.dtype[np.float64]], ask_sizes_raw: np.ndarray[Any, np.dtype[np.float64]], ts_events: np.ndarray[Any, np.dtype[np.uint64]], ts_inits: np.ndarray[Any, np.dtype[np.uint64]]) -> list[QuoteTick]: ...
    @staticmethod
    def list_from_capsule(capsule: Any) -> list[QuoteTick]: ...
    @staticmethod
    def capsule_from_list(items: list[QuoteTick]) -> Any: ...
    @staticmethod
    def from_raw(instrument_id: InstrumentId, bid_price_raw: PriceRaw, ask_price_raw: PriceRaw, bid_price_prec: int, ask_price_prec: int, bid_size_raw: QuantityRaw, ask_size_raw: QuantityRaw, bid_size_prec: int, ask_size_prec: int, ts_event: int, ts_init: int) -> QuoteTick: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> QuoteTick: ...
    @staticmethod
    def to_dict(obj: QuoteTick) -> dict[str, Any]: ...
    @staticmethod
    def from_pyo3_list(pyo3_quotes: list[nautilus_pyo3.QuoteTick]) -> list[QuoteTick]: ...
    @staticmethod
    def to_pyo3_list(quotes: list[QuoteTick]) -> list[nautilus_pyo3.QuoteTick]: ...
    @staticmethod
    def from_pyo3(pyo3_quote: nautilus_pyo3.QuoteTick) -> QuoteTick: ...
    def to_pyo3(self) -> nautilus_pyo3.QuoteTick: ...
    def extract_price(self, price_type: PriceType) -> Price: ...
    def extract_size(self, price_type: PriceType) -> Quantity: ...

class TradeTick(Data):

    def __init__(self, instrument_id: InstrumentId, price: Price, size: Quantity, aggressor_side: AggressorSide, trade_id: TradeId, ts_event: int, ts_init: int) -> None: ...
    def __getstate__(self) -> tuple[str, int, int, int, int, AggressorSide, str, int, int]: ...
    def __setstate__(self, state: tuple[str, int, int, int, int, AggressorSide, str, int, int]) -> None: ...
    def __eq__(self, other: TradeTick) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def instrument_id(self) -> InstrumentId: ...
    @property
    def trade_id(self) -> TradeId: ...
    @property
    def price(self) -> Price: ...
    @property
    def size(self) -> Quantity: ...
    @property
    def aggressor_side(self) -> AggressorSide: ...
    @property
    def ts_event(self) -> int: ...
    @property
    def ts_init(self) -> int: ...
    @staticmethod
    def from_raw_arrays_to_list(
        instrument_id: InstrumentId, 
        price_prec: int, 
        size_prec: int, 
        prices_raw: np.ndarray, # skip-validate
        sizes_raw: np.ndarray, # skip-validate
        aggressor_sides: np.ndarray, # skip-validate
        trade_ids: list[str], 
        ts_events: np.ndarray, # skip-validate
        ts_inits: np.ndarray # skip-validate
    ) -> list[TradeTick]: ...
    @staticmethod
    def list_from_capsule(capsule: Any) -> list[TradeTick]: ...
    @staticmethod
    def capsule_from_list(items: list[TradeTick]) -> Any: ...
    @staticmethod
    def from_raw(instrument_id: InstrumentId, price_raw: PriceRaw, price_prec: int, size_raw: QuantityRaw, size_prec: int, aggressor_side: AggressorSide, trade_id: TradeId, ts_event: int, ts_init: int) -> TradeTick: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> TradeTick: ...
    @staticmethod
    def to_dict(obj: TradeTick) -> dict[str, Any]: ...
    @staticmethod
    def to_pyo3_list(trades: list[TradeTick]) -> list[nautilus_pyo3.TradeTick]: ...
    @staticmethod
    def from_pyo3_list(pyo3_trades: list[nautilus_pyo3.TradeTick]) -> list[TradeTick]: ...
    @staticmethod
    def from_pyo3(pyo3_trade: nautilus_pyo3.TradeTick) -> TradeTick: ...
    def to_pyo3(self) -> nautilus_pyo3.TradeTick: ...

class MarkPriceUpdate(Data):

    def __init__(self, instrument_id: InstrumentId, value: Price, ts_event: int, ts_init: int) -> None: ...
    def __eq__(self, other: MarkPriceUpdate) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def instrument_id(self) -> InstrumentId: ...
    @property
    def value(self) -> Price: ...
    @property
    def ts_event(self) -> int: ...
    @property
    def ts_init(self) -> int: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> MarkPriceUpdate: ...
    @staticmethod
    def to_dict(obj: MarkPriceUpdate) -> dict[str, Any]: ...
    @staticmethod
    def to_pyo3_list(mark_prices: list[MarkPriceUpdate]) -> list[nautilus_pyo3.MarkPriceUpdate]: ...
    @staticmethod
    def from_pyo3_list(pyo3_mark_prices: list[nautilus_pyo3.MarkPriceUpdate]) -> list[MarkPriceUpdate]: ...
    @staticmethod
    def from_pyo3(pyo3_mark_price: nautilus_pyo3.MarkPriceUpdate) -> MarkPriceUpdate: ...
    def to_pyo3(self) -> nautilus_pyo3.MarkPriceUpdate: ...

class IndexPriceUpdate(Data):

    instrument_id: InstrumentId
    value: Price
    ts_event: int
    ts_init: int
    def __init__(self, instrument_id: InstrumentId, value: Price, ts_event: int, ts_init: int) -> None: ...
    def __eq__(self, other: IndexPriceUpdate) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def from_dict(values: dict[str, Any]) -> IndexPriceUpdate: ...
    @staticmethod
    def to_dict(obj: IndexPriceUpdate) -> dict[str, Any]: ...
    @staticmethod
    def to_pyo3_list(index_prices: list[IndexPriceUpdate]) -> list[nautilus_pyo3.IndexPriceUpdate]: ...
    @staticmethod
    def from_pyo3_list(pyo3_index_prices: list[nautilus_pyo3.IndexPriceUpdate]) -> list[IndexPriceUpdate]: ...
    @staticmethod
    def from_pyo3(pyo3_index_price: nautilus_pyo3.IndexPriceUpdate) -> IndexPriceUpdate: ...
    def to_pyo3(self) -> nautilus_pyo3.IndexPriceUpdate: ...
