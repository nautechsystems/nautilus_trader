from collections.abc import Callable
from datetime import datetime
from datetime import timedelta
from datetime import tzinfo
from typing import Any

import nautilus_trader
from nautilus_trader.common.config import NautilusConfig
from nautilus_trader.common.enums import ComponentState
from nautilus_trader.common.enums import ComponentTrigger
from nautilus_trader.common.enums import LogColor
from nautilus_trader.common.enums import LogLevel
from nautilus_trader.core import nautilus_pyo3
from stubs.core.message import Event
from stubs.core.message import Request
from stubs.core.message import Response
from stubs.core.uuid import UUID4
from stubs.model.identifiers import ComponentId
from stubs.model.identifiers import Identifier
from stubs.model.identifiers import TraderId
from stubs.serialization.base import Serializer

_COMPONENT_CLOCKS: dict[UUID4, list[TestClock]]
_FORCE_STOP: bool
LOGGING_PYO3: bool


class Clock:

    @property
    def timer_names(self) -> list[str]: ...

    @property
    def timer_count(self) -> int: ...

    def timestamp(self) -> float: ...

    def timestamp_ms(self) -> int: ...

    def timestamp_us(self) -> int: ...

    def timestamp_ns(self) -> int: ...

    def utc_now(self) -> datetime: ...

    def local_now(self, tz: tzinfo | None = None) -> datetime: ...

    def register_default_handler(self, handler: Callable[TimeEvent, None]) -> None: ...

    def next_time_ns(self, name: str) -> int: ...

    def set_time_alert(
        self,
        name: str,
        alert_time: datetime,
        callback: Callable[TimeEvent, None] | None = None,
        override: bool = False,
        allow_past: bool = True,
    ) -> None: ...

    def set_time_alert_ns(
        self,
        name: str,
        alert_time_ns: int,
        callback: Callable[TimeEvent, None] | None = None,
        allow_past: bool = True,
    ) -> None: ...

    def set_timer(
        self,
        name: str,
        interval: timedelta,
        start_time: datetime | None = None,
        stop_time: datetime | None = None,
        callback: Callable[TimeEvent, None] | None = None,
        allow_past: bool = True,
        fire_immediately: bool = False,
    ) -> None: ...

    def set_timer_ns(
        self,
        name: str,
        interval_ns: int,
        start_time_ns: int,
        stop_time_ns: int,
        callback: Callable[TimeEvent, None] | None = None,
        allow_past: bool = True,
        fire_immediately: bool = False,
    ) -> None: ...

    def cancel_timer(self, name: str) -> None: ...

    def cancel_timers(self) -> None: ...


def get_component_clocks(instance_id: UUID4) -> listTestClock: ...
def register_component_clock(instance_id: UUID4, clock: Clock) -> None: ...
def deregister_component_clock(instance_id: UUID4, clock: Clock) -> None: ...
def remove_instance_component_clocks(instance_id: UUID4) -> None: ...
def set_backtest_force_stop(value: bool) -> None: ...
def is_backtest_force_stop() -> bool: ...


class TestClock(Clock):

    __test__: bool = ...

    def __init__(self) -> None: ...
    def __del__(self) -> None: ...

    @property
    def timer_names(self) -> list[str]: ...

    @property
    def timer_count(self) -> int: ...

    def timestamp(self) -> float: ...
    def timestamp_ms(self) -> int: ...
    def timestamp_us(self) -> int: ...
    def timestamp_ns(self) -> int: ...
    def register_default_handler(self, callback: Callable[TimeEvent, None]) -> None: ...

    def set_time_alert_ns(
        self,
        name: str,
        alert_time_ns: int,
        callback: Callable[TimeEvent, None] | None = None,
        allow_past: bool = True,
    ) -> None: ...

    def set_timer_ns(
        self,
        name: str,
        interval_ns: int,
        start_time_ns: int,
        stop_time_ns: int,
        callback: Callable[TimeEvent, None] | None = None,
        allow_past: bool = True,
        fire_immediately: bool = False,
    ) -> None: ...

    def next_time_ns(self, name: str) -> int: ...
    def cancel_timer(self, name: str) -> None: ...
    def cancel_timers(self) -> None: ...

    def set_time(self, to_time_ns: int) -> None: ...

    def advance_time(self, to_time_ns: int, set_time: bool = True) -> list[TimeEventHandler]: ...


class LiveClock(Clock):

    def __init__(self) -> None: ...
    def __del__(self) -> None: ...

    @property
    def timer_names(self) -> list[str]: ...

    @property
    def timer_count(self) -> int: ...

    def timestamp(self) -> float: ...
    def timestamp_ms(self) -> int: ...
    def timestamp_us(self) -> int: ...
    def timestamp_ns(self) -> int: ...
    def register_default_handler(self, callback: Callable[TimeEvent, None]) -> None: ...

    def set_time_alert_ns(
        self,
        name: str,
        alert_time_ns: int,
        callback: Callable[TimeEvent, None] | None = None,
        allow_past: bool = True,
    ) -> None: ...

    def set_timer_ns(
        self,
        name: str,
        interval_ns: int,
        start_time_ns: int,
        stop_time_ns: int,
        callback: Callable[TimeEvent, None] | None = None,
        allow_past: bool = True,
        fire_immediately: bool = False,
    ) -> None: ...

    def next_time_ns(self, name: str) -> int: ...
    def cancel_timer(self, name: str) -> None: ...
    def cancel_timers(self) -> None: ...


def create_pyo3_conversion_wrapper(callback: Any) -> Callable[[Any], Any]: ...


class TimeEvent(Event):

    def __init__(
        self,
        name: str,
        event_id: UUID4,
        ts_event: int,
        ts_init: int,
    ) -> None: ...

    def __getstate__(self) -> Any: ...
    def __setstate__(self, state: Any) -> None: ...

    def __eq__(self, other: TimeEvent) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    @property
    def name(self) -> str: ...

    @property
    def id(self) -> UUID4: ...

    @property
    def ts_event(self) -> int: ...

    @property
    def ts_init(self) -> int: ...


class TimeEventHandler:

    event: TimeEvent

    def __init__(
        self,
        event: TimeEvent,
        handler: Callable[[TimeEvent], None],
    ) -> None: ...

    def handle(self) -> None: ...

    def __eq__(self, other: TimeEventHandler) -> bool: ...
    def __lt__(self, other: TimeEventHandler) -> bool: ...
    def __le__(self, other: TimeEventHandler) -> bool: ...
    def __gt__(self, other: TimeEventHandler) -> bool: ...
    def __ge__(self, other: TimeEventHandler) -> bool: ...
    def __repr__(self) -> str: ...


RECV: str = ...
SENT: str = ...
CMD: str = ...
EVT: str = ...
DOC: str = ...
RPT: str = ...
REQ: str = ...
RES: str = ...


def set_logging_clock_realtime_mode() -> None: ...
def set_logging_clock_static_mode() -> None: ...
def set_logging_clock_static_time(time_ns: int) -> None: ...
def log_color_from_str(value: str) -> LogColor: ...
def log_color_to_str(value: LogColor) -> str: ...
def log_level_from_str(value: str) -> LogLevel: ...
def log_level_to_str(value: LogLevel) -> str: ...


class LogGuard:

    def __del__(self) -> None: ...


def init_logging(
    trader_id: TraderId | None = None,
    machine_id: str | None = None,
    instance_id: UUID4 | None = None,
    level_stdout: LogLevel = ...,
    level_file: LogLevel = ...,
    directory: str | None = None,
    file_name: str | None = None,
    file_format: str | None = None,
    component_levels: dict[ComponentId, LogLevel] | None = None,
    colors: bool = True,
    bypass: bool = False,
    print_config: bool = False,
    max_file_size: int = 0,
    max_backup_count: int = 5,
) -> LogGuard:
    ...


def is_logging_initialized() -> bool: ...
def is_logging_pyo3() -> bool: ...
def set_logging_pyo3(value: bool) -> None: ...
def flush_logger() -> None: ...


class Logger:

    def __init__(self, name: str) -> None: ...

    @property
    def name(self) -> str: ...

    def debug(
        self,
        message: str,
        color: LogColor = ...,
    ) -> None: ...

    def info(
        self, message: str,
        color: LogColor = ...,
    ) -> None: ...

    def warning(
        self,
        message: str,
        color: LogColor = ...,
    ) -> None: ...

    def error(
        self,
        message: str,
        color: LogColor = ...,
    ) -> None: ...

    def exception(
        self,
        message: str,
        ex,
    ) -> None: ...


def log_header(
    trader_id: TraderId,
    machine_id: str,
    instance_id: UUID4,
    component: str,
) -> None: ...


def log_sysinfo(component: str) -> None: ...


def component_state_from_str(value: str) -> ComponentState: ...
def component_state_to_str(value: ComponentState) -> str: ...
def component_trigger_from_str(value: str) -> ComponentTrigger: ...
def component_trigger_to_str(value: ComponentTrigger) -> str: ...


class ComponentFSMFactory:

    @staticmethod
    def get_state_transition_table() -> dict: ...

    @staticmethod
    def create() -> nautilus_trader.core.fsm.FiniteStateMachine: ...


class Component:

    trader_id: TraderId | None
    id: Identifier
    type: type

    def __init__(
        self,
        clock: Clock,
        trader_id: TraderId | None = None,
        component_id: Identifier | None = None,
        component_name: str | None = None,
        msgbus: MessageBus | None = None,
        config: NautilusConfig | None = None,
    ) -> None: ...

    def __eq__(self, other: Component) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    @classmethod
    def fully_qualified_name(cls) -> str: ...

    @property
    def state(self) -> ComponentState: ...

    @property
    def is_initialized(self) -> bool: ...

    @property
    def is_running(self) -> bool: ...

    @property
    def is_stopped(self) -> bool: ...

    @property
    def is_disposed(self) -> bool: ...

    @property
    def is_degraded(self) -> bool: ...

    @property
    def is_faulted(self) -> bool: ...

    def _start(self) -> None: ...
    def _stop(self) -> None: ...
    def _resume(self) -> None: ...
    def _reset(self) -> None: ...
    def _dispose(self) -> None: ...
    def _degrade(self) -> None: ...
    def _fault(self) -> None: ...

    def start(self) -> None: ...

    def stop(self) -> None: ...

    def resume(self) -> None: ...

    def reset(self) -> None: ...

    def dispose(self) -> None: ...

    def degrade(self) -> None: ...

    def fault(self) -> None: ...

    def shutdown_system(self, reason: str | None = None) -> None: ...


class MessageBus:

    trader_id: TraderId
    serializer: Serializer
    has_backing: bool
    sent_count: int
    req_count: int
    res_count: int
    pub_count: int

    _clock: Clock
    _log: Logger
    _database: nautilus_pyo3.RedisMessageBusDatabase | None
    _listeners: list[nautilus_pyo3.MessageBusListener]
    _endpoints: dict[str, Callable[[Any], None]]
    _patterns: dict[str, Any] # Changed from Subscription[:] due to type hint complexities
    _subscriptions: dict[Subscription, list[str]]
    _correlation_index: dict[UUID4, Callable[[Any], None]]
    _publishable_types: tuple[type, ...]
    _streaming_types: set[type]
    _resolved: bool

    def __init__(
        self,
        trader_id: TraderId,
        clock: Clock,
        instance_id: UUID4 | None = None,
        name: str | None = None,
        serializer: Serializer | None = None,
        database: nautilus_pyo3.RedisMessageBusDatabase | None = None,
        config: Any | None = None,
    ) -> None: ...

    def endpoints(self) -> list[str]: ...

    def topics(self) -> list[str]: ...

    def subscriptions(self, pattern: str | None = None) -> list[Subscription]: ...

    def streaming_types(self) -> set[type]: ...

    def has_subscribers(self, pattern: str | None = None) -> bool: ...

    def is_subscribed(self, topic: str, handler: Callable[[Any], None]) -> bool: ...

    def is_pending_request(self, request_id: UUID4) -> bool: ...

    def is_streaming_type(self, cls: type) -> bool: ...

    def dispose(self) -> None: ...

    def register(self, endpoint: str, handler: Callable[[Any], None]) -> None: ...

    def deregister(self, endpoint: str, handler: Callable[[Any], None]) -> None: ...

    def add_streaming_type(self, cls: type) -> None: ...

    def add_listener(self, listener: nautilus_pyo3.MessageBusListener) -> None: ...

    def send(self, endpoint: str, msg: Any) -> None: ...

    def request(self, endpoint: str, request: Request) -> None: # Cannot import Request without circular dependency
        ...

    def response(self, response: Response) -> None: # Cannot import Response without circular dependency
        ...

    def subscribe(
        self,
        topic: str,
        handler: Callable[[Any], None],
        priority: int = 0,
    ) -> None: ...

    def unsubscribe(self, topic: str, handler: Callable[[Any], None]) -> None: ...

    def publish(self, topic: str, msg: Any, external_pub: bool = True) -> None: ...


def is_matching_py(topic: str, pattern: str) -> bool: ...


class Subscription:

    topic: str
    handler: Callable[[Any], None]
    priority: int

    def __init__(
        self,
        topic: str,
        handler: Callable[[Any], None],
        priority: int = 0,
    ) -> None: ...

    def __eq__(self, other: Subscription) -> bool: ...
    def __lt__(self, other: Subscription) -> bool: ...
    def __le__(self, other: Subscription) -> bool: ...
    def __gt__(self, other: Subscription) -> bool: ...
    def __ge__(self, other: Subscription) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...


class Throttler:

    name: str
    limit: int
    interval: timedelta
    is_limiting: bool
    recv_count: int
    sent_count: int

    def __init__(
        self,
        name: str,
        limit: int,
        interval: timedelta,
        clock: Clock,
        output_send: Callable[[Any], None],
        output_drop: Callable[[Any], None] | None = None,
    ) -> None: ...

    @property
    def qsize(self) -> int: ...

    def reset(self) -> None: ...

    def used(self) -> float: ...

    def send(self, msg) -> None: ...

    def _process(self, event: TimeEvent) -> None: ...
    def _resume(self, event: TimeEvent) -> None: ...

